/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { TypedEmitter } from 'tiny-typed-emitter';
import WebSocketExtensions from 'websocket-extensions';
import StreamedOutgoingMessage from './streams/StreamedOutgoingMessage';
import State from './enums/State';
import { WebSocketStats, BaseWebSocketOptions, WsFrame, WebSocketEvents } from './interfaces-internal';
import { Socket } from 'net';
import { TLSSocket } from 'tls';
import Timer = NodeJS.Timer;
export default class WebSocketBase extends TypedEmitter<WebSocketEvents> {
    state: State;
    protocol?: string;
    stats: WebSocketStats;
    options: BaseWebSocketOptions;
    remoteAddress: string;
    _socket: Socket | TLSSocket;
    _extensions: WebSocketExtensions;
    _data: object;
    _outgoingFrames: any;
    _dataBuffer: Buffer;
    _incomingStream: any;
    _extensionProcessingOutgoingFrameId: number;
    _pingFailures: number;
    _userTimeout?: Timer;
    _userTimeoutMs?: number;
    _pingCallbacks: object;
    _pingTimer: Timer;
    _pingTimeout: Timer;
    _type: string;
    constructor();
    _onConnected(): void;
    /**
     * Disconnect the websocket gracefully.
     * @param {number} [code=StatusCode.NormalClosure] - A value from the StatusCode enum to send to the other side
     * @param {string} [reason] - An optional reason string to send to the other side
     */
    disconnect(code?: number, reason?: string): void;
    /**
     * Send some data in a single frame (not streamed).
     * @param {string|Buffer} data - The data to send. If a string, the data will be sent as UTF-8 text. If a Buffer, it will be sent as binary data.
     */
    send(data: any): void;
    createMessageStream(type: any): StreamedOutgoingMessage;
    data(key: string, value: any): any;
    getPeerCertificate(detailed?: boolean): import("tls").PeerCertificate;
    getSecurityProtocol(): string;
    _prepSocketEvents(): void;
    setTimeout(timeout: number, callback?: () => void): this;
    _resetUserTimeout(): void;
    sendPing(callback: () => void): void;
    _queuePing(): void;
    _handleData(data?: Buffer): void;
    _handleFrame(frame: WsFrame): void;
    _dispatchDataFrame(frame: WsFrame): void;
    _sendFrame(frame: WsFrame, bypassQueue?: boolean): void;
    _processQueue(): void;
    _sendControl(opcode: number, payload: Buffer): void;
    _closeError(err: Error): void;
    _terminateError(code?: number, message?: string): void;
    _cleanupTimers(): void;
    _closeExtensions(callback?: () => void): void;
}
//# sourceMappingURL=WebSocketBase.d.ts.map