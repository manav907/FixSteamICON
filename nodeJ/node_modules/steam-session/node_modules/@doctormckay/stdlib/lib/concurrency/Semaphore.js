"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Semaphore_instances, _Semaphore_queue, _Semaphore_next;
Object.defineProperty(exports, "__esModule", { value: true });
const AsyncQueue_1 = __importDefault(require("../data_structures/AsyncQueue"));
class Semaphore {
    /**
     * Create a new semaphore.
     * @param [concurrency=1]
     * @constructor
     */
    constructor(concurrency = 1) {
        _Semaphore_instances.add(this);
        _Semaphore_queue.set(this, void 0);
        __classPrivateFieldSet(this, _Semaphore_queue, new AsyncQueue_1.default((item, callback) => __classPrivateFieldGet(this, _Semaphore_instances, "m", _Semaphore_next).call(this, item, callback), concurrency), "f");
    }
    get free() {
        return this.isFree();
    }
    /**
     * Wait for the semaphore to be available and call the provided function when available.
     * @param {function} callback
     */
    wait(callback) {
        if (typeof callback !== 'function') {
            throw new Error(`Argument to wait must be of type function; ${typeof callback} given`);
        }
        __classPrivateFieldGet(this, _Semaphore_queue, "f").push(callback);
    }
    /**
     * Wait for the semaphore to be available and resolve the returned function when available.
     * The result of the resolved promise is a release() function that you must call when you're done with your work and
     * are ready to release the semaphore.
     * @return Promise<function>
     */
    waitAsync() {
        return new Promise(resolve => this.wait(resolve));
    }
    /**
     * Returns whether the semaphore is currently free. A semaphore is free if a call to wait() would result in immediate
     * invocation.
     * @return {boolean}
     */
    isFree() {
        return __classPrivateFieldGet(this, _Semaphore_queue, "f").running < __classPrivateFieldGet(this, _Semaphore_queue, "f").concurrency && __classPrivateFieldGet(this, _Semaphore_queue, "f").length == 0;
    }
}
exports.default = Semaphore;
_Semaphore_queue = new WeakMap(), _Semaphore_instances = new WeakSet(), _Semaphore_next = function _Semaphore_next(item, callback) {
    item(() => callback(null));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VtYXBob3JlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xpYi9jb25jdXJyZW5jeS9TZW1hcGhvcmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrRUFBdUQ7QUFFdkQsTUFBcUIsU0FBUztJQUc3Qjs7OztPQUlHO0lBQ0gsWUFBWSxXQUFXLEdBQUcsQ0FBQzs7UUFQM0IsbUNBQW1CO1FBUWxCLHVCQUFBLElBQUksb0JBQVUsSUFBSSxvQkFBVSxDQUFDLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsdUJBQUEsSUFBSSw2Q0FBTSxNQUFWLElBQUksRUFBTyxJQUFJLEVBQUUsUUFBUSxDQUFDLEVBQUUsV0FBVyxDQUFDLE1BQUEsQ0FBQztJQUMzRixDQUFDO0lBRUQsSUFBSSxJQUFJO1FBQ1AsT0FBTyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILElBQUksQ0FBQyxRQUF1QztRQUMzQyxJQUFJLE9BQU8sUUFBUSxLQUFLLFVBQVUsRUFBRTtZQUNuQyxNQUFNLElBQUksS0FBSyxDQUFDLDhDQUE4QyxPQUFPLFFBQVEsUUFBUSxDQUFDLENBQUM7U0FDdkY7UUFFRCx1QkFBQSxJQUFJLHdCQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzVCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFNBQVM7UUFDUixPQUFPLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTTtRQUNMLE9BQU8sdUJBQUEsSUFBSSx3QkFBTyxDQUFDLE9BQU8sR0FBRyx1QkFBQSxJQUFJLHdCQUFPLENBQUMsV0FBVyxJQUFJLHVCQUFBLElBQUksd0JBQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDO0lBQ2pGLENBQUM7Q0FVRDtBQXZERCw0QkF1REM7bUhBSE0sSUFBbUMsRUFBRSxRQUErQjtJQUN6RSxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDNUIsQ0FBQyJ9