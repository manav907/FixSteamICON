"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TTLCache_instances, _TTLCache_container, _TTLCache_ttl, _TTLCache_gc, _TTLCache_gcKey;
Object.defineProperty(exports, "__esModule", { value: true });
// This import isn't necessary for Node.js, but it is for Electron.
// Ref: https://dev.doctormckay.com/topic/4606-typeerror-setintervalunref-is-not-a-function/
const timers_1 = require("timers");
class TTLCache {
    /**
     * Construct a new TTLCache.
     * @param {int} ttlMilliseconds - Default time to live in milliseconds for each entry
     * @param {int} [gcIntervalMilliseconds=300000] - Time between garbage collections (default 1 minute)
     * @constructor
     */
    constructor(ttlMilliseconds, gcIntervalMilliseconds = 60000) {
        _TTLCache_instances.add(this);
        _TTLCache_container.set(this, void 0);
        _TTLCache_ttl.set(this, void 0);
        __classPrivateFieldSet(this, _TTLCache_container, new Map(), "f");
        __classPrivateFieldSet(this, _TTLCache_ttl, ttlMilliseconds, "f");
        // Force a GC every minute
        (0, timers_1.setInterval)(() => __classPrivateFieldGet(this, _TTLCache_instances, "m", _TTLCache_gc).call(this), gcIntervalMilliseconds).unref();
    }
    /**
     * Add an entry to the cache.
     * @param {string} key - The key under which this entry should be stored
     * @param {any} value - The value to store in this entry
     * @param {int} ttlMilliseconds - Optionally set a TTL for this specific entry, rather than using the default global TTL
     */
    add(key, value, ttlMilliseconds) {
        let ttl = ttlMilliseconds || __classPrivateFieldGet(this, _TTLCache_ttl, "f");
        __classPrivateFieldGet(this, _TTLCache_container, "f").set(key, {
            value,
            expire: Date.now() + ttl
        });
    }
    /**
     * Get the entry stored in the cache under a particular key.
     * @param {string} key - The key to retrieve
     * @return {null|*} value if present, null if not
     */
    get(key) {
        // Collect garbage on just this key if applicable, to ensure that we don't return an expired value
        __classPrivateFieldGet(this, _TTLCache_instances, "m", _TTLCache_gcKey).call(this, key);
        if (!__classPrivateFieldGet(this, _TTLCache_container, "f").has(key)) {
            return null;
        }
        let { value } = __classPrivateFieldGet(this, _TTLCache_container, "f").get(key);
        return value;
    }
    /**
     * Delete an entry from the cache.
     * @param {string} key
     * @returns {void}
     */
    delete(key) {
        __classPrivateFieldGet(this, _TTLCache_container, "f").delete(key);
    }
    /**
     * Get a list of all keys in the cache.
     * @returns {string[]}
     */
    getKeys() {
        __classPrivateFieldGet(this, _TTLCache_instances, "m", _TTLCache_gc).call(this);
        return [...__classPrivateFieldGet(this, _TTLCache_container, "f").keys()];
    }
    /**
     * Clear the cache.
     * @returns {void}
     */
    clear() {
        __classPrivateFieldGet(this, _TTLCache_container, "f").clear();
    }
}
exports.default = TTLCache;
_TTLCache_container = new WeakMap(), _TTLCache_ttl = new WeakMap(), _TTLCache_instances = new WeakSet(), _TTLCache_gc = function _TTLCache_gc() {
    // We cannot use getKeys() since that calls #gc() and would cause recursion
    let keys = [...__classPrivateFieldGet(this, _TTLCache_container, "f").keys()];
    keys.forEach(key => __classPrivateFieldGet(this, _TTLCache_instances, "m", _TTLCache_gcKey).call(this, key));
}, _TTLCache_gcKey = function _TTLCache_gcKey(key) {
    let val = __classPrivateFieldGet(this, _TTLCache_container, "f").get(key);
    if (!val) {
        return;
    }
    if (val.expire < Date.now()) {
        __classPrivateFieldGet(this, _TTLCache_container, "f").delete(key);
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVFRMQ2FjaGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbGliL2RhdGFfc3RydWN0dXJlcy9UVExDYWNoZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLG1FQUFtRTtBQUNuRSw0RkFBNEY7QUFDNUYsbUNBQW1DO0FBRW5DLE1BQXFCLFFBQVE7SUFJNUI7Ozs7O09BS0c7SUFDSCxZQUFZLGVBQXVCLEVBQUUseUJBQWlDLEtBQUs7O1FBVDNFLHNDQUE2RDtRQUM3RCxnQ0FBc0I7UUFTckIsdUJBQUEsSUFBSSx1QkFBYyxJQUFJLEdBQUcsRUFBc0MsTUFBQSxDQUFDO1FBQ2hFLHVCQUFBLElBQUksaUJBQVEsZUFBZSxNQUFBLENBQUM7UUFFNUIsMEJBQTBCO1FBQzFCLElBQUEsb0JBQVcsRUFBQyxHQUFHLEVBQUUsQ0FBQyx1QkFBQSxJQUFJLHlDQUFJLE1BQVIsSUFBSSxDQUFNLEVBQUUsc0JBQXNCLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUMvRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxHQUFHLENBQUMsR0FBVyxFQUFFLEtBQVEsRUFBRSxlQUF3QjtRQUNsRCxJQUFJLEdBQUcsR0FBRyxlQUFlLElBQUksdUJBQUEsSUFBSSxxQkFBSyxDQUFDO1FBRXZDLHVCQUFBLElBQUksMkJBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFO1lBQ3hCLEtBQUs7WUFDTCxNQUFNLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUc7U0FDeEIsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxHQUFHLENBQUMsR0FBVztRQUNkLGtHQUFrRztRQUNsRyx1QkFBQSxJQUFJLDRDQUFPLE1BQVgsSUFBSSxFQUFRLEdBQUcsQ0FBQyxDQUFDO1FBRWpCLElBQUksQ0FBQyx1QkFBQSxJQUFJLDJCQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzlCLE9BQU8sSUFBSSxDQUFDO1NBQ1o7UUFFRCxJQUFJLEVBQUMsS0FBSyxFQUFDLEdBQUcsdUJBQUEsSUFBSSwyQkFBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2QyxPQUFPLEtBQUssQ0FBQztJQUNkLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLEdBQVc7UUFDakIsdUJBQUEsSUFBSSwyQkFBVyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsT0FBTztRQUNOLHVCQUFBLElBQUkseUNBQUksTUFBUixJQUFJLENBQU0sQ0FBQztRQUNYLE9BQU8sQ0FBQyxHQUFHLHVCQUFBLElBQUksMkJBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLO1FBQ0osdUJBQUEsSUFBSSwyQkFBVyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ3pCLENBQUM7Q0FzQkQ7QUFoR0QsMkJBZ0dDOztJQWZDLDJFQUEyRTtJQUMzRSxJQUFJLElBQUksR0FBRyxDQUFDLEdBQUcsdUJBQUEsSUFBSSwyQkFBVyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7SUFDdkMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLHVCQUFBLElBQUksNENBQU8sTUFBWCxJQUFJLEVBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUN2QyxDQUFDLDZDQUVNLEdBQVc7SUFDakIsSUFBSSxHQUFHLEdBQUcsdUJBQUEsSUFBSSwyQkFBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNuQyxJQUFJLENBQUMsR0FBRyxFQUFFO1FBQ1QsT0FBTztLQUNQO0lBRUQsSUFBSSxHQUFHLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRTtRQUM1Qix1QkFBQSxJQUFJLDJCQUFXLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQzVCO0FBQ0YsQ0FBQyJ9