"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const stdlib_1 = __importDefault(require("@doctormckay/stdlib"));
const http_1 = require("@doctormckay/stdlib/http");
const crypto_1 = require("crypto");
const debug_1 = __importDefault(require("debug"));
const https_1 = __importDefault(require("https"));
const socks_proxy_agent_1 = require("socks-proxy-agent");
const steamid_1 = __importDefault(require("steamid"));
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const AuthenticationClient_1 = __importDefault(require("./AuthenticationClient"));
const helpers_1 = require("./helpers");
const WebApiTransport_1 = __importDefault(require("./transports/WebApiTransport"));
const WebSocketCMTransport_1 = __importDefault(require("./transports/WebSocketCMTransport"));
const EAuthSessionGuardType_1 = __importDefault(require("./enums-steam/EAuthSessionGuardType"));
const EAuthTokenPlatformType_1 = __importDefault(require("./enums-steam/EAuthTokenPlatformType"));
const EResult_1 = __importDefault(require("./enums-steam/EResult"));
const ESessionPersistence_1 = __importDefault(require("./enums-steam/ESessionPersistence"));
const debug = (0, debug_1.default)('steam-session:LoginSession');
/**
 * Using CommonJS:
 * ```js
 * const {LoginSession} = require('steam-session');
 * ```
 *
 * Using ES6 modules:
 * ```js
 * import {LoginSession} from 'steam-session';
 * ```
 *
 * The {@link LoginSession} class is the primary way to interact with steam-session.
 *
 * @see Example: [login-with-password.ts](https://github.com/DoctorMcKay/node-steam-session/blob/master/examples/login-with-password.ts)
 * @see Example: [login-with-qr.ts](https://github.com/DoctorMcKay/node-steam-session/blob/master/examples/login-with-qr.ts)
 */
class LoginSession extends tiny_typed_emitter_1.TypedEmitter {
    /**
     * @param {EAuthTokenPlatformType} platformType - A value from {@link EAuthTokenPlatformType}.
     * You should set this to the appropriate platform type for your desired usage.
     * @param {ConstructorOptions} [options]
     * @return
     *
     * Constructs a new `LoginSession` instance. Example usage:
     *
     * ```js
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let session = new LoginSession(EAuthTokenPlatformType.WebBrowser);
     * ```
     */
    constructor(platformType, options) {
        super();
        options = options || {};
        let mutuallyExclusiveOptions = ['localAddress', 'httpProxy', 'socksProxy', 'agent'];
        if (Object.keys(options).filter(k => mutuallyExclusiveOptions.includes(k)).length > 1) {
            throw new Error('Cannot specify more than one of localAddress, httpProxy, socksProxy, or agent at the same time');
        }
        let agent = options.agent || new https_1.default.Agent({ keepAlive: true });
        if (options.httpProxy) {
            agent = stdlib_1.default.HTTP.getProxyAgent(true, options.httpProxy);
        }
        else if (options.socksProxy) {
            agent = new socks_proxy_agent_1.SocksProxyAgent(options.socksProxy);
        }
        this._webClient = new http_1.HttpClient({
            httpsAgent: agent,
            localAddress: options.localAddress
        });
        this._platformType = platformType;
        let transport = options.transport;
        if (!transport) {
            switch (platformType) {
                case EAuthTokenPlatformType_1.default.SteamClient:
                    transport = new WebSocketCMTransport_1.default(this._webClient, agent, options.localAddress);
                    break;
                default:
                    transport = new WebApiTransport_1.default(this._webClient);
            }
        }
        this._handler = new AuthenticationClient_1.default({
            platformType: this._platformType,
            transport,
            webClient: this._webClient,
            webUserAgent: options.userAgent || (0, helpers_1.defaultUserAgent)(),
            machineId: options.machineId
        });
        this._handler.on('debug', (...args) => this.emit('debug-handler', ...args));
        this.on('debug', debug);
        this.loginTimeout = 30000;
    }
    /**
     * A `number` specifying the time, in milliseconds, before a login attempt will {@link timeout}. The timer begins
     * after {@link polling} begins.
     *
     * If you attempt to set this property after {@link polling} has already been emitted, an Error will be thrown since
     * setting this property after that point has no effect.
     */
    get loginTimeout() {
        return this._loginTimeout;
    }
    set loginTimeout(value) {
        if (this._pollingStartedTime) {
            throw new Error('Setting loginTimeout after polling has already started is ineffective');
        }
        this._loginTimeout = value;
    }
    /**
     * **Read-only.** A [`SteamID`](https://www.npmjs.com/package/steamid) instance containing the SteamID for the
     * currently-authenticated account. Populated immediately after {@link startWithCredentials}
     * resolves, or immediately after {@link accessToken} or {@link refreshToken} are set (meaning that
     * this is always populated when {@link authenticated} fires).
     */
    get steamID() {
        // There's a few places we could get a steamid from
        if (this._startSessionResponse && this._startSessionResponse.steamId) {
            return new steamid_1.default(this._startSessionResponse.steamId);
        }
        else if (this.accessToken || this.refreshToken) {
            let token = this.accessToken || this.refreshToken;
            let decodedToken = (0, helpers_1.decodeJwt)(token);
            return new steamid_1.default(decodedToken.sub);
        }
        else {
            return null;
        }
    }
    /**
     * **Read-only.** A `string` containing your account name. This is populated just before the {@link authenticated}
     * event is fired.
     */
    get accountName() { return this._accountName; }
    /**
     * A `string` containing your access token. As of 2023-09-12, Steam does not return an access token in response to
     * successful authentication, so this won't be set when the {@link authenticated} event is fired. This will be set
     * after you call {@link refreshAccessToken} or {@link renewRefreshToken}. Also, since {@link getWebCookies} calls
     * {@link refreshAccessToken} internally for {@link EAuthTokenPlatformType.SteamClient | EAuthTokenPlatformType.SteamClient}
     * or {@link EAuthTokenPlatformType.MobileApp | MobileApp}, this will also be set after calling {@link getWebCookies}
     * for those platform types.
     *
     * You can also assign an access token to this property if you already have one, although at present that wouldn't
     * do anything useful.
     *
     * Setting this property will throw an Error if:
     *
     * - You set it to a token that isn't well-formed, or
     * - You set it to a refresh token rather than an access token, or
     * - You have already called {@link startWithCredentials} and you set it to a token that doesn't belong to the same account, or
     * - You have already set {@link refreshToken} and you set this to a token that doesn't belong to the same account as the refresh token
     *
     * Access tokens can't be used for much. You can use them with a few undocumented WebAPIs like
     * [IFriendsListService/GetFriendsList](https://steamapi.xpaw.me/#IFriendsListService/GetFriendsList) by passing the access
     * token as an access_token query string parameter. For example:
     *
     *     https://api.steampowered.com/IFriendsListService/GetFriendsList/v1/?access_token=eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...
     *
     * As of time of writing (2023-04-24), it appears that you can also use access tokens with regular published API methods,
     * for example:
     *
     *     https://api.steampowered.com/ISteamUserStats/GetNumberOfCurrentPlayers/v1/?appid=440&access_token=eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...
     *
     * node-steamcommunity also has a method you can use to provide it with an access token:
     * [`setMobileAppAccessToken`](https://github.com/DoctorMcKay/node-steamcommunity/wiki/SteamCommunity#setmobileappaccesstokenaccesstoken)
     */
    get accessToken() { return this._accessToken; }
    set accessToken(token) {
        if (!token) {
            this._accessToken = token;
            return;
        }
        let decoded = (0, helpers_1.decodeJwt)(token);
        try {
            new steamid_1.default(decoded.sub);
        }
        catch {
            throw new Error('Not a valid Steam token');
        }
        let aud = decoded.aud || [];
        if (aud.includes('derive')) {
            throw new Error('The provided token is a refresh token, not an access token');
        }
        if (this._startSessionResponse
            && this._startSessionResponse.steamId
            && decoded.sub != this._startSessionResponse.steamId) {
            throw new Error('Token is for a different account. To work with a different account, create a new LoginSession.');
        }
        if (this._refreshToken) {
            let decodedRefreshToken = (0, helpers_1.decodeJwt)(this._refreshToken);
            if (decodedRefreshToken.sub != decoded.sub) {
                throw new Error('This access token belongs to a different account from the set refresh token.');
            }
        }
        // Everything checks out
        this._accessToken = token;
        this._accessTokenSetAt = new Date();
    }
    /**
     * A `string` containing your refresh token. This is populated just before the {@link authenticated} event is fired.
     * You can also assign a refresh token to this property if you already have one.
     *
     * Setting this property will throw an Error if:
     *
     * - You set it to a token that isn't well-formed, or
     * - You set it to an access token rather than a refresh token, or
     * - You have already called {@link startWithCredentials} and you set it to a token that doesn't belong to the same account, or
     * - You have already set {@link accessToken} and you set this to a token that doesn't belong to the same account as the access token
     */
    get refreshToken() { return this._refreshToken; }
    set refreshToken(token) {
        if (!token) {
            this._refreshToken = token;
            return;
        }
        let decoded = (0, helpers_1.decodeJwt)(token);
        try {
            new steamid_1.default(decoded.sub);
        }
        catch {
            throw new Error('Not a valid Steam token');
        }
        let aud = decoded.aud || [];
        if (!aud.includes('derive')) {
            throw new Error('The provided token is an access token, not a refresh token');
        }
        let requiredAudience = 'unknown';
        switch (this._platformType) {
            case EAuthTokenPlatformType_1.default.SteamClient:
                requiredAudience = 'client';
                break;
            case EAuthTokenPlatformType_1.default.MobileApp:
                requiredAudience = 'mobile';
                break;
            case EAuthTokenPlatformType_1.default.WebBrowser:
                requiredAudience = 'web';
                break;
        }
        if (!aud.includes(requiredAudience)) {
            throw new Error(`Token platform type is different from the platform type of this LoginSession instance (required audience "${requiredAudience}" but got "${aud.join(',')}"`);
        }
        if (this._startSessionResponse
            && this._startSessionResponse.steamId
            && decoded.sub != this._startSessionResponse.steamId) {
            throw new Error('Token is for a different account. To work with a different account, create a new LoginSession.');
        }
        if (this._accessToken) {
            let decodedAccessToken = (0, helpers_1.decodeJwt)(this._accessToken);
            if (decodedAccessToken.sub != decoded.sub) {
                throw new Error('This refresh token belongs to a different account from the set access token.');
            }
        }
        // Everything checks out
        this._refreshToken = token;
    }
    /**
     * **Read-only.** A `string` containing your Steam Guard machine token. This is populated when you pass a `steamGuardMachineToken` to
     * {@link startWithCredentials}, or just before the {@link steamGuardMachineToken} event is emitted.
     */
    get steamGuardMachineToken() { return this._steamGuardMachineToken; }
    get _defaultWebsiteId() {
        switch (this._platformType) {
            case EAuthTokenPlatformType_1.default.SteamClient:
                return 'Client';
            case EAuthTokenPlatformType_1.default.WebBrowser:
                return 'Community';
            case EAuthTokenPlatformType_1.default.MobileApp:
                return 'Mobile';
            default:
                return 'Community';
        }
    }
    _verifyStarted(mustHaveSteamId = false) {
        if (!this._startSessionResponse) {
            throw new Error('Login session has not been started yet');
        }
        if (this._pollingCanceled) {
            throw new Error('Login attempt has been canceled');
        }
        if (mustHaveSteamId && !this.steamID) {
            throw new Error('Cannot use this method with this login scheme');
        }
    }
    /**
     * @param details
     * @return
     *
     * Starts a new login attempt using your account credentials. Returns a Promise.
     *
     * If you're logging in with {@link EAuthTokenPlatformType.SteamClient | EAuthTokenPlatformType.SteamClient}, you
     * can supply a Buffer containing the SHA-1 hash of your sentry file for
     * {@link StartLoginSessionWithCredentialsDetails.steamGuardMachineToken}.
     *
     * For example:
     *
     *
     * ```js
     * import {createHash} from 'crypto';
     * import {readFileSync} from 'fs';
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let hash = createHash('sha1');
     * hash.update(readFileSync('ssfn1234567890'));
     * let buffer = hash.digest(); // buffer contains a Buffer
     *
     * let session = new LoginSession(EAuthTokenPlatformType.SteamClient);
     * session.startWithCredentials({
     *     accountName: 'johndoe',
     *     password: 'h3ll0wor1d',
     *     steamGuardMachineToken: buffer
     * });
     * ```
     *
     * If you supply a {@link StartLoginSessionWithCredentialsDetails.steamGuardCode} here and you're using email-based
     * Steam Guard, Steam will send you a new Steam Guard email if you're using {@link EAuthTokenPlatformType.SteamClient | EAuthTokenPlatformType.SteamClient}
     * or {@link EAuthTokenPlatformType.MobileApp}. You would ideally keep your LoginSession active that generated your
     * first email, and pass the code using {@link submitSteamGuardCode} instead of creating a new LoginSession and
     * supplying the code to {@link startWithCredentials}.
     *
     * On failure, the Promise will be rejected with its message being equal to the string representation of an {@link EResult}
     * value. There will also be an `eresult` property on the Error object equal to the numeric representation of the relevant
     * EResult value. For example:
     *
     * ```
     * Error: InvalidPassword
     *   eresult: 5
     * ```
     *
     * On success, the Promise will be resolved with a {@link StartSessionResponse} object.
     *
     * Here's a list of which guard types might be present in this method's response, and how you should proceed:
     *
     * - {@link EAuthSessionGuardType.EmailCode}: An email was sent to you containing a code
     *   (`detail` contains your email address' domain, e.g. `gmail.com`).
     *   You should get that code and either call {@link submitSteamGuardCode}, or create a new {@link LoginSession}
     *   and supply that code to the {@link StartLoginSessionWithCredentialsDetails.steamGuardCode} property when calling
     *   {@link startWithCredentials}.
     * - {@link EAuthSessionGuardType.DeviceCode}: You need to supply a TOTP code from your mobile authenticator
     *   (or by using [steam-totp](https://www.npmjs.com/package/steam-totp)).
     *   Get that code and either call {@link submitSteamGuardCode}, or create a new {@link LoginSession} and supply that
     *   code to the {@link StartLoginSessionWithCredentialsDetails.steamGuardCode} property when calling {@link startWithCredentials}.
     * - {@link EAuthSessionGuardType.DeviceConfirmation}: You need to approve the confirmation prompt in your Steam
     *   mobile app. If this guard type is present, {@link polling} will start and {@link loginTimeout} will be in effect.
     * - {@link EAuthSessionGuardType.EmailConfirmation}: You need to approve the confirmation email sent to you. If this
     *   guard type is present, {@link polling} will start and {@link loginTimeout} will be in effect.
     *
     * Note that multiple guard types might be available; for example both {@link EAuthSessionGuardType.DeviceCode} and
     * {@link EAuthSessionGuardType.DeviceConfirmation} can be available at the same time.
     *
     * When this method resolves, {@link steamID} will be populated.
     */
    async startWithCredentials(details) {
        if (this._startSessionResponse) {
            throw new Error('A session has already been started on this LoginSession object. Create a new LoginSession to start a new session.');
        }
        this._hadRemoteInteraction = false;
        this._steamGuardCode = details.steamGuardCode;
        if (typeof details.steamGuardMachineToken == 'string') {
            this._steamGuardMachineToken = details.steamGuardMachineToken;
        }
        let encryptionResult = await this._handler.encryptPassword(details.accountName, details.password);
        this._startSessionResponse = await this._handler.startSessionWithCredentials({
            accountName: details.accountName,
            ...encryptionResult,
            persistence: details.persistence || ESessionPersistence_1.default.Persistent,
            platformType: this._platformType,
            // use a manually-specified token with priority over a token saved on this object
            steamGuardMachineToken: details.steamGuardMachineToken || this.steamGuardMachineToken
        });
        this.emit('debug', 'start session response', this._startSessionResponse);
        return await this._processStartSessionResponse();
    }
    /**
     * @return
     *
     * Starts a new QR login attempt. Returns a Promise.
     *
     * On failure, the Promise will be rejected with its message being equal to the string representation of an {@link EResult}
     * value. There will also be an `eresult` property on the Error object equal to the numeric representation of the relevant
     * EResult value. Realistically, failures should never happen unless Steam is having problems or you're having network issues.
     *
     * On success, the Promise will be resolved with a {@link StartSessionResponse} object.
     *
     * {@link steamID} will not be populated when this method resolves, since at this point we don't know which account
     * we're going to log into. It will be populated after you successfully {@link authenticated | authenticate}.
     *
     * Immediately after this resolves, {@link LoginSession} will start {@link polling} to determine when authentication
     * has succeeded.
     */
    async startWithQR() {
        if (this._startSessionResponse) {
            throw new Error('A session has already been started on this LoginSession object. Create a new LoginSession to start a new session.');
        }
        this._hadRemoteInteraction = false;
        this._startSessionResponse = await this._handler.startSessionWithQR();
        this.emit('debug', 'start qr session response', this._startSessionResponse);
        return await this._processStartSessionResponse();
    }
    async _processStartSessionResponse() {
        this._pollingCanceled = false;
        let validActions = [];
        for (let i of this._startSessionResponse.allowedConfirmations) {
            switch (i.type) {
                case EAuthSessionGuardType_1.default.None:
                    this.emit('debug', 'no guard required');
                    // Use setImmediate here so that the promise is resolved before we potentially emit a session
                    setImmediate(() => this._doPoll());
                    return { actionRequired: false };
                case EAuthSessionGuardType_1.default.EmailCode:
                case EAuthSessionGuardType_1.default.DeviceCode:
                    let codeType = i.type == EAuthSessionGuardType_1.default.EmailCode ? 'email' : 'device';
                    this.emit('debug', `${codeType} code required`);
                    let authResult = await (codeType == 'email' ? this._attemptEmailCodeAuth() : this._attemptTotpCodeAuth());
                    if (authResult) {
                        // We successfully authed already, no action needed
                        return { actionRequired: false };
                    }
                    else {
                        // We need a code from the user
                        let action = { type: i.type };
                        if (i.message) {
                            action.detail = i.message;
                        }
                        validActions.push(action);
                        break;
                    }
                case EAuthSessionGuardType_1.default.DeviceConfirmation:
                case EAuthSessionGuardType_1.default.EmailConfirmation:
                    this.emit('debug', 'device or email confirmation guard required');
                    validActions.push({ type: i.type });
                    setImmediate(() => this._doPoll());
                    break;
                case EAuthSessionGuardType_1.default.MachineToken:
                    // Do nothing here since this is handled by _attemptEmailCodeAuth
                    break;
                default:
                    let guardTypeString = i.type.toString();
                    for (let j in EAuthSessionGuardType_1.default) {
                        if (EAuthSessionGuardType_1.default[j] == guardTypeString) {
                            guardTypeString = j;
                            break;
                        }
                    }
                    throw new Error(`Unknown auth session guard type ${guardTypeString}`);
            }
        }
        // If we got here but we have no valid actions, something went wrong
        if (validActions.length == 0) {
            throw new Error('Login requires action, but we can\'t tell what kind of action is required');
        }
        let response = {
            actionRequired: true,
            validActions
        };
        if (this._startSessionResponse.challengeUrl) {
            let startSessionResponse = this._startSessionResponse;
            response.qrChallengeUrl = startSessionResponse.challengeUrl;
        }
        return response;
    }
    /**
     * @return
     *
     * Forces an immediate polling attempt. This will throw an `Error` if you call it before the {@link polling} event is
     * emitted, after {@link authenticated} is emitted, or after you call {@link cancelLoginAttempt}.
     */
    forcePoll() {
        this._verifyStarted();
        if (!this._pollingStartedTime) {
            throw new Error('Polling has not yet started');
        }
        this._doPoll();
    }
    async _doPoll() {
        if (this._pollingCanceled) {
            return;
        }
        // If we called _doPoll outside of an existing timer, cancel the timer
        clearTimeout(this._pollTimer);
        if (!this._pollingStartedTime) {
            this._pollingStartedTime = Date.now();
            this.emit('polling');
        }
        let totalPollingTime = Date.now() - this._pollingStartedTime;
        if (totalPollingTime >= this.loginTimeout) {
            this.emit('timeout');
            this.cancelLoginAttempt();
            return;
        }
        let pollResponse;
        try {
            pollResponse = await this._handler.pollLoginStatus(this._startSessionResponse);
            this.emit('debug', 'poll response', pollResponse);
        }
        catch (ex) {
            // If we got an error, but we've already canceled polling, just do nothing.
            if (!this._pollingCanceled) {
                this.emit('error', ex);
                this.cancelLoginAttempt();
            }
            return;
        }
        this._startSessionResponse.clientId = pollResponse.newClientId || this._startSessionResponse.clientId;
        if (pollResponse.hadRemoteInteraction && !this._hadRemoteInteraction) {
            this._hadRemoteInteraction = true;
            this.emit('remoteInteraction');
        }
        if (pollResponse.newSteamGuardMachineAuth) {
            this._steamGuardMachineToken = pollResponse.newSteamGuardMachineAuth;
            this.emit('steamGuardMachineToken');
        }
        if (pollResponse.refreshToken) {
            this._accountName = pollResponse.accountName;
            this.refreshToken = pollResponse.refreshToken;
            this.accessToken = pollResponse.accessToken || null;
            // On 2023-09-12, Steam stopped issuing access tokens alongside refresh tokens for newly authenticated sessions.
            // This won't affect any consumer apps that use `getWebCookies()`, since that will acquire an access token if
            // needed.
            // On 2023-09-22, I noticed that Steam started issuing access tokens again. ¯\_(ツ)_/¯
            // Consumers using SteamClient or WebBrowser never had a reason to consume the accessToken property directly,
            // since that was only useful as a cookie and `getWebCookies()` should be used instead. However, the access
            // token is also used as a WebAPI key for MobileApp, so we should probably ensure that we have one for that
            // platform.
            if (!this.accessToken && this._platformType == EAuthTokenPlatformType_1.default.MobileApp) {
                await this.refreshAccessToken();
            }
            this.emit('authenticated');
            this.cancelLoginAttempt();
        }
        else if (!this._pollingCanceled) {
            this._pollTimer = setTimeout(() => this._doPoll(), this._startSessionResponse.pollInterval * 1000);
        }
    }
    /**
     * @returns {boolean} - true if code submitted successfully, false if code wasn't valid or no code available
     */
    async _attemptEmailCodeAuth() {
        if (this._steamGuardCode) {
            try {
                await this.submitSteamGuardCode(this._steamGuardCode);
                return true;
            }
            catch (ex) {
                if (ex.eresult != EResult_1.default.InvalidLoginAuthCode) {
                    // this is some kind of important error
                    throw ex;
                }
            }
        }
        // Can we use a machine auth token?
        if (this._platformType == EAuthTokenPlatformType_1.default.WebBrowser
            && this._startSessionResponse.allowedConfirmations.some(c => c.type == EAuthSessionGuardType_1.default.MachineToken)) {
            let result = await this._handler.checkMachineAuthOrSendCodeEmail({
                machineAuthToken: this.steamGuardMachineToken,
                ...this._startSessionResponse
            });
            this.emit('debug', `machine auth check response: ${EResult_1.default[result.result]}`);
            if (result.result == EResult_1.default.OK) {
                // Machine auth succeeded
                setImmediate(() => this._doPoll());
                return true;
            }
        }
        // An email was sent
        return false;
    }
    async _attemptTotpCodeAuth() {
        if (this._steamGuardCode) {
            try {
                await this.submitSteamGuardCode(this._steamGuardCode);
                return true; // submitting code succeeded
            }
            catch (ex) {
                if (ex.eresult != EResult_1.default.TwoFactorCodeMismatch) {
                    // this is some kind of important error
                    throw ex;
                }
            }
        }
        // If we got here, then we need the user to supply a code
        return false;
    }
    /**
     * @param authCode - Your Steam Guard code
     * @return
     *
     * If a Steam Guard code is needed, you can supply it using this method. Returns a Promise.
     *
     * On failure, the Promise will be rejected with its message being equal to the string representation of an {@link EResult}
     * value. There will also be an `eresult` property on the Error object equal to the numeric representation of the relevant
     * EResult value. For example:
     *
     * ```
     * Error: TwoFactorCodeMismatch
     *   eresult: 88
     * ```
     *
     * Note that an incorrect email code will fail with EResult value {@link EResult.InvalidLoginAuthCode} (65), and an
     * incorrect TOTP code will fail with EResult value {@link EResult.TwoFactorCodeMismatch} (88).
     *
     * On success, the Promise will be resolved with no value. In this case, you should expect for {@link authenticated}
     * to be emitted shortly.
     */
    async submitSteamGuardCode(authCode) {
        this._verifyStarted(true);
        this.emit('debug', 'submitting steam guard code', authCode);
        let needsEmailCode = this._startSessionResponse.allowedConfirmations.some(c => c.type == EAuthSessionGuardType_1.default.EmailCode);
        let needsTotpCode = this._startSessionResponse.allowedConfirmations.some(c => c.type == EAuthSessionGuardType_1.default.DeviceCode);
        if (!needsEmailCode && !needsTotpCode) {
            throw new Error('No Steam Guard code is needed for this login attempt');
        }
        await this._handler.submitSteamGuardCode({
            ...this._startSessionResponse,
            authCode,
            authCodeType: needsEmailCode ? EAuthSessionGuardType_1.default.EmailCode : EAuthSessionGuardType_1.default.DeviceCode
        });
        setImmediate(() => this._doPoll());
    }
    /**
     * @return - True if we were actively polling and it has now been canceled. False if we were not polling.
     *
     * Cancels {@link polling} for an ongoing login attempt. Once canceled, you should no longer interact with this
     * {@link LoginSession} object, and you should create a new one if you want to start a new attempt.
     */
    cancelLoginAttempt() {
        this._pollingCanceled = true;
        this._handler.close();
        if (this._pollTimer) {
            clearTimeout(this._pollTimer);
            return true;
        }
        return false;
    }
    /**
     * @return
     *
     * Once successfully {@link authenticated}, you can call this method to get cookies for use on the Steam websites.
     * You can also manually set {@link refreshToken} and then call this method without going through another login
     * attempt if you already have a valid refresh token. Returns a Promise.
     *
     * On failure, the Promise will be rejected. Depending on the nature of the failure, an {@link EResult} may or may
     * not be available.
     *
     * On success, the Promise will be resolved with an array of strings. Each string contains a cookie, e.g.
     * `'steamLoginSecure=blahblahblahblah'`.
     *
     * Here's an example of how you can get new web cookies when you already have a valid refresh token:
     *
     * ```js
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let session = new LoginSession(EAuthTokenPlatformType.WebBrowser);
     * session.refreshToken = 'eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...';
     * let cookies = await session.getWebCookies();
     * ```
     */
    async getWebCookies() {
        if (!this.refreshToken) {
            throw new Error('A refresh token is required to get web cookies');
        }
        let sessionId = (0, crypto_1.randomBytes)(12).toString('hex');
        // If our platform type is MobileApp or SteamClient, then our access token *is* our session cookie.
        // The same is likely true for WebBrowser, but we want to mimic official behavior as closely as possible to avoid
        // any potential future breakage.
        if ([EAuthTokenPlatformType_1.default.SteamClient, EAuthTokenPlatformType_1.default.MobileApp].includes(this._platformType)) {
            if (!this.accessToken || Date.now() - this._accessTokenSetAt.getTime() > (1000 * 60 * 10)) {
                // Refresh our access token if we either don't have one, or the token we have is greater than 10 minutes old.
                // Technically we could just decode the JWT and find out when it expires (or was issued), but let's try
                // to minimize how much we depend on the access token being a JWT (as Valve may change it at any point).
                await this.refreshAccessToken();
            }
            let cookieValue = encodeURIComponent([this.steamID.getSteamID64(), this.accessToken].join('||'));
            return [`steamLoginSecure=${cookieValue}`, `sessionid=${sessionId}`];
        }
        let body = {
            nonce: this.refreshToken,
            sessionid: sessionId,
            redir: 'https://steamcommunity.com/login/home/?goto='
        };
        debug('POST https://login.steampowered.com/jwt/finalizelogin %o', body);
        let finalizeResponse = await this._webClient.request({
            method: 'POST',
            url: 'https://login.steampowered.com/jwt/finalizelogin',
            headers: helpers_1.API_HEADERS,
            multipartForm: http_1.HttpClient.simpleObjectToMultipartForm(body)
        });
        if (finalizeResponse.jsonBody && finalizeResponse.jsonBody.error) {
            throw (0, helpers_1.eresultError)(finalizeResponse.jsonBody.error);
        }
        if (!finalizeResponse.jsonBody || !finalizeResponse.jsonBody.transfer_info) {
            let err = new Error('Malformed login response');
            err.responseBody = finalizeResponse.jsonBody;
            throw err;
        }
        // Now we want to execute all transfers specified in the finalizelogin response. Technically we only need one
        // successful transfer (hence the usage of promsieAny), but we execute them all for robustness in case one fails.
        // As long as one succeeds, we're good.
        let transfers = finalizeResponse.jsonBody.transfer_info.map(({ url, params }) => new Promise(async (resolve, reject) => {
            let body = { steamID: this.steamID.getSteamID64(), ...params };
            debug('POST %s %o', url, body);
            let result;
            try {
                result = await this._webClient.request({
                    method: 'POST',
                    url,
                    multipartForm: http_1.HttpClient.simpleObjectToMultipartForm(body)
                });
            }
            catch (error) {
                return reject(error);
            }
            if (!result.headers || !result.headers['set-cookie'] || result.headers['set-cookie'].length == 0) {
                return reject(new Error('No Set-Cookie header in result'));
            }
            if (!result.headers['set-cookie'].some(c => c.startsWith('steamLoginSecure='))) {
                return reject(new Error('No steamLoginSecure cookie in result'));
            }
            let domain = new URL(url).host;
            resolve(result.headers['set-cookie'].map(cookie => !cookie.toLowerCase().includes('domain=') ? `${cookie}; Domain=${domain}` : cookie));
        }));
        let cookies = [];
        (await Promise.all(transfers)).forEach((domainCookies) => {
            cookies = cookies.concat(domainCookies);
        });
        // Filter out any sessionid cookies we might have, since we want to set one that works for everything
        cookies = cookies.filter(c => !c.startsWith('sessionid='));
        // Now add in a sessionid cookie
        cookies.push(`sessionid=${sessionId}`);
        return cookies;
    }
    /**
     * @return
     *
     * As long as a {@link refreshToken} is set, you can call this method to obtain a new access token.
     * Returns a Promise.
     *
     * On failure, the Promise will be rejected. An {@link EResult} will be available under the `eresult` property of
     * the Error object.
     *
     * On success, the Promise will be resolved with no value. You can then read the access token from the LoginSession's
     * {@link accessToken} property.
     *
     * ```js
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let session = new LoginSession(EAuthTokenPlatformType.WebBrowser);
     * session.refreshToken = 'eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...';
     * await session.refreshAccessToken();
     *
     * console.log(`New access token: ${session.accessToken}`);
     * ```
     *
     * As of 2023-04-24, this method works for {@link EAuthTokenPlatformType.MobileApp | EAuthTokenPlatformType.MobileApp}
     * and {@link EAuthTokenPlatformType.SteamClient}, but using {@link EAuthTokenPlatformType.WebBrowser} will fail
     * with response {@link EResult.AccessDenied}.
     */
    async refreshAccessToken() {
        if (!this.refreshToken) {
            throw new Error('A refresh token is required to get a new access token');
        }
        this.accessToken = (await this._handler.generateAccessTokenForApp(this.refreshToken)).accessToken;
    }
    /**
     * @return boolean
     *
     * Does the same thing as {@link refreshAccessToken}, while also attempting to renew your refresh token.
     *
     * Whether a new refresh token will actually be issued is at the discretion of the Steam backend. This method will
     * return true if a new refresh token was issued (which can be accessed using the {@link refreshToken} property), or
     * false if no new refresh token was issued. Regardless of the return value, the {@link accessToken} property is
     * always updated with a fresh access token (unless there was an error).
     *
     * **Important:** If a refresh token is successfully renewed (e.g. this method returns true), the old refresh token
     * will become invalid, even if it is not yet expired.
     */
    async renewRefreshToken() {
        if (!this.refreshToken) {
            throw new Error('A refresh token is required to get a new access token');
        }
        let { accessToken, refreshToken } = await this._handler.generateAccessTokenForApp(this.refreshToken, true);
        this.accessToken = accessToken;
        this.refreshToken = refreshToken || this.refreshToken;
        return !!refreshToken;
    }
}
exports.default = LoginSession;
////////////////////////////
// DOCS FOR EVENTS FOLLOW //
////////////////////////////
/**
 * This event is emitted once we start polling Steam to periodically check if the login attempt has succeeded or not.
 * Polling starts when any of these conditions are met:
 *
 * - A login session is successfully started with credentials and no guard is required (e.g. Steam Guard is disabled)*
 * - A login session is successfully started with credentials and you supplied a valid code to {@link StartLoginSessionWithCredentialsDetails.steamGuardCode}*
 * - A login session is successfully started with credentials, you're using email Steam Guard, and you supplied a valid {@link StartLoginSessionWithCredentialsDetails.steamGuardMachineToken}*
 * - A login session is successfully started with credentials, then you supplied a valid code to {@link submitSteamGuardCode}*
 * - A login session is successfully started, and {@link EAuthSessionGuardType.DeviceConfirmation} or {@link EAuthSessionGuardType.EmailConfirmation} are among the valid guards
 * 	 - This case covers {@link startWithQR | QR logins}, since a QR login is a device confirmation under the hood
 *
 * \* = in these cases, we expect to only have to poll once before login succeeds.
 *
 * After this event is emitted, if your {@link loginTimeout} elapses and the login attempt has not yet succeeded,
 * {@link timeout} is emitted and the login attempt is abandoned. You would then need to start a new login attempt
 * using a fresh {@link LoginSession} object.
 *
 * @event
 */
LoginSession.polling = 'polling';
/**
 * This event is emitted when the time specified by {@link loginTimeout} elapses after {@link polling} begins, and
 * the login attempt has not yet succeeded. When `timeout` is emitted, {@link cancelLoginAttempt} is called internally.
 *
 * @event
 */
LoginSession.timeout = 'timeout';
/**
 * This event is emitted when Steam reports a "remote interaction" via {@link polling}. This is observed to happen
 * when the approval prompt is viewed in the Steam mobile app for the {@link EAuthSessionGuardType.DeviceConfirmation}
 * guard. For a {@link startWithQR | QR login}, this would be after you scan the code, but before you tap approve or deny.
 *
 * @event
 */
LoginSession.remoteInteraction = 'remoteInteraction';
/**
 * This event is emitted when Steam sends us a new Steam Guard machine token. Machine tokens are only relevant when logging
 * into an account that has email-based Steam Guard enabled. Thus, this will only be emitted after successfully logging into
 * such an account.
 *
 * At this time, this event is only emitted when logging in using {@link EAuthTokenPlatformType.SteamClient | EAuthTokenPlatformType.SteamClient}.
 * It's not presently possible to get a machine token for the {@link EAuthTokenPlatformType.WebBrowser} platform
 * (and {@link EAuthTokenPlatformType.MobileApp} platform doesn't support machine tokens at all).
 *
 * When this event is emitted, the {@link LoginSession#steamGuardMachineToken} property contains your new machine token.
 *
 * @event
 */
LoginSession.steamGuardMachineToken = 'steamGuardMachineToken';
/**
 * This event is emitted when we successfully authenticate with Steam. At this point, {@link accountName}
 * and {@link refreshToken} are populated. If the {@link EAuthTokenPlatformType}
 * passed to the {@link constructor} is appropriate, you can now safely call {@link getWebCookies}.
 *
 * @event
 */
LoginSession.authenticated = 'authenticated';
/**
 * This event is emitted if we encounter an error while {@link polling}. The first argument to the event handler is
 * an Error object. If this happens, the login attempt has failed and will need to be retried.
 *
 * Node.js will crash if this event is emitted and not handled.
 *
 * ```js
 * session.on('error', (err) => {
 *     console.error(`An error occurred: ${err.message}`);
 * });
 * ```
 *
 * @event
 */
LoginSession.error = 'error';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9naW5TZXNzaW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL0xvZ2luU2Vzc2lvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlFQUF5QztBQUN6QyxtREFBa0U7QUFDbEUsbUNBQW1DO0FBQ25DLGtEQUFnQztBQUNoQyxrREFBMEI7QUFDMUIseURBQWtEO0FBQ2xELHNEQUE4QjtBQUM5QiwyREFBZ0Q7QUFFaEQsa0ZBQTBEO0FBQzFELHVDQUFpRjtBQUVqRixtRkFBMkQ7QUFDM0QsNkZBQXFFO0FBY3JFLGdHQUF3RTtBQUN4RSxrR0FBMEU7QUFDMUUsb0VBQTRDO0FBQzVDLDRGQUFvRTtBQUVwRSxNQUFNLEtBQUssR0FBRyxJQUFBLGVBQVcsRUFBQyw0QkFBNEIsQ0FBQyxDQUFDO0FBbUJ4RDs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxNQUFxQixZQUFhLFNBQVEsaUNBQWdDO0lBc0J6RTs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0gsWUFBWSxZQUFvQyxFQUFFLE9BQTRCO1FBQzdFLEtBQUssRUFBRSxDQUFDO1FBRVIsT0FBTyxHQUFHLE9BQU8sSUFBSSxFQUFFLENBQUM7UUFFeEIsSUFBSSx3QkFBd0IsR0FBRyxDQUFDLGNBQWMsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3BGLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ3RGLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0dBQWdHLENBQUMsQ0FBQztTQUNsSDtRQUVELElBQUksS0FBSyxHQUFlLE9BQU8sQ0FBQyxLQUFLLElBQUksSUFBSSxlQUFLLENBQUMsS0FBSyxDQUFDLEVBQUMsU0FBUyxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7UUFFNUUsSUFBSSxPQUFPLENBQUMsU0FBUyxFQUFFO1lBQ3RCLEtBQUssR0FBRyxnQkFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxTQUFTLENBQWdCLENBQUM7U0FDMUU7YUFBTSxJQUFJLE9BQU8sQ0FBQyxVQUFVLEVBQUU7WUFDOUIsS0FBSyxHQUFHLElBQUksbUNBQWUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDaEQ7UUFFRCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksaUJBQVUsQ0FBQztZQUNoQyxVQUFVLEVBQUUsS0FBSztZQUNqQixZQUFZLEVBQUUsT0FBTyxDQUFDLFlBQVk7U0FDbEMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLGFBQWEsR0FBRyxZQUFZLENBQUM7UUFFbEMsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQztRQUNsQyxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2YsUUFBUSxZQUFZLEVBQUU7Z0JBQ3JCLEtBQUssZ0NBQXNCLENBQUMsV0FBVztvQkFDdEMsU0FBUyxHQUFHLElBQUksOEJBQW9CLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO29CQUNuRixNQUFNO2dCQUVQO29CQUNDLFNBQVMsR0FBRyxJQUFJLHlCQUFlLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQ2xEO1NBQ0Q7UUFFRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksOEJBQW9CLENBQUM7WUFDeEMsWUFBWSxFQUFFLElBQUksQ0FBQyxhQUFhO1lBQ2hDLFNBQVM7WUFDVCxTQUFTLEVBQUUsSUFBSSxDQUFDLFVBQVU7WUFDMUIsWUFBWSxFQUFFLE9BQU8sQ0FBQyxTQUFTLElBQUksSUFBQSwwQkFBZ0IsR0FBRTtZQUNyRCxTQUFTLEVBQUUsT0FBTyxDQUFDLFNBQVM7U0FDNUIsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUM1RSxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUV4QixJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsSUFBSSxZQUFZO1FBQ2YsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0lBQzNCLENBQUM7SUFFRCxJQUFJLFlBQVksQ0FBQyxLQUFhO1FBQzdCLElBQUksSUFBSSxDQUFDLG1CQUFtQixFQUFFO1lBQzdCLE1BQU0sSUFBSSxLQUFLLENBQUMsdUVBQXVFLENBQUMsQ0FBQztTQUN6RjtRQUVELElBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDO0lBQzVCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILElBQUksT0FBTztRQUNWLG1EQUFtRDtRQUNuRCxJQUFJLElBQUksQ0FBQyxxQkFBcUIsSUFBSyxJQUFJLENBQUMscUJBQWlFLENBQUMsT0FBTyxFQUFFO1lBQ2xILE9BQU8sSUFBSSxpQkFBTyxDQUFFLElBQUksQ0FBQyxxQkFBaUUsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNwRzthQUFNLElBQUksSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ2pELElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQztZQUNsRCxJQUFJLFlBQVksR0FBRyxJQUFBLG1CQUFTLEVBQUMsS0FBSyxDQUFDLENBQUM7WUFDcEMsT0FBTyxJQUFJLGlCQUFPLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3JDO2FBQU07WUFDTixPQUFPLElBQUksQ0FBQztTQUNaO0lBQ0YsQ0FBQztJQUVEOzs7T0FHRztJQUNILElBQUksV0FBVyxLQUFhLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFFdkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0ErQkc7SUFDSCxJQUFJLFdBQVcsS0FBYSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELElBQUksV0FBVyxDQUFDLEtBQWE7UUFDNUIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNYLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO1lBQzFCLE9BQU87U0FDUDtRQUVELElBQUksT0FBTyxHQUFHLElBQUEsbUJBQVMsRUFBQyxLQUFLLENBQUMsQ0FBQztRQUUvQixJQUFJO1lBQUUsSUFBSSxpQkFBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUFFO1FBQUMsTUFBTTtZQUN2QyxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7U0FDM0M7UUFFRCxJQUFJLEdBQUcsR0FBRyxPQUFPLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQztRQUM1QixJQUFJLEdBQUcsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEtBQUssQ0FBQyw0REFBNEQsQ0FBQyxDQUFDO1NBQzlFO1FBRUQsSUFDQyxJQUFJLENBQUMscUJBQXFCO2VBQ3RCLElBQUksQ0FBQyxxQkFBaUUsQ0FBQyxPQUFPO2VBQy9FLE9BQU8sQ0FBQyxHQUFHLElBQUssSUFBSSxDQUFDLHFCQUFpRSxDQUFDLE9BQU8sRUFDaEc7WUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLGdHQUFnRyxDQUFDLENBQUM7U0FDbEg7UUFFRCxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDdkIsSUFBSSxtQkFBbUIsR0FBRyxJQUFBLG1CQUFTLEVBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3hELElBQUksbUJBQW1CLENBQUMsR0FBRyxJQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7Z0JBQzNDLE1BQU0sSUFBSSxLQUFLLENBQUMsOEVBQThFLENBQUMsQ0FBQzthQUNoRztTQUNEO1FBRUQsd0JBQXdCO1FBQ3hCLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO1FBQzFCLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gsSUFBSSxZQUFZLEtBQWEsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztJQUN6RCxJQUFJLFlBQVksQ0FBQyxLQUFhO1FBQzdCLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDWCxJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztZQUMzQixPQUFPO1NBQ1A7UUFFRCxJQUFJLE9BQU8sR0FBRyxJQUFBLG1CQUFTLEVBQUMsS0FBSyxDQUFDLENBQUM7UUFFL0IsSUFBSTtZQUFFLElBQUksaUJBQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7U0FBRTtRQUFDLE1BQU07WUFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1NBQzNDO1FBRUQsSUFBSSxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUM7UUFDNUIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyw0REFBNEQsQ0FBQyxDQUFDO1NBQzlFO1FBRUQsSUFBSSxnQkFBZ0IsR0FBRyxTQUFTLENBQUM7UUFDakMsUUFBUSxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQzNCLEtBQUssZ0NBQXNCLENBQUMsV0FBVztnQkFDdEMsZ0JBQWdCLEdBQUcsUUFBUSxDQUFDO2dCQUM1QixNQUFNO1lBRVAsS0FBSyxnQ0FBc0IsQ0FBQyxTQUFTO2dCQUNwQyxnQkFBZ0IsR0FBRyxRQUFRLENBQUM7Z0JBQzVCLE1BQU07WUFFUCxLQUFLLGdDQUFzQixDQUFDLFVBQVU7Z0JBQ3JDLGdCQUFnQixHQUFHLEtBQUssQ0FBQztnQkFDekIsTUFBTTtTQUNQO1FBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtZQUNwQyxNQUFNLElBQUksS0FBSyxDQUFDLDZHQUE2RyxnQkFBZ0IsY0FBYyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUM3SztRQUVELElBQ0MsSUFBSSxDQUFDLHFCQUFxQjtlQUN0QixJQUFJLENBQUMscUJBQWlFLENBQUMsT0FBTztlQUMvRSxPQUFPLENBQUMsR0FBRyxJQUFLLElBQUksQ0FBQyxxQkFBaUUsQ0FBQyxPQUFPLEVBQ2hHO1lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxnR0FBZ0csQ0FBQyxDQUFDO1NBQ2xIO1FBRUQsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3RCLElBQUksa0JBQWtCLEdBQUcsSUFBQSxtQkFBUyxFQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUN0RCxJQUFJLGtCQUFrQixDQUFDLEdBQUcsSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO2dCQUMxQyxNQUFNLElBQUksS0FBSyxDQUFDLDhFQUE4RSxDQUFDLENBQUM7YUFDaEc7U0FDRDtRQUVELHdCQUF3QjtRQUN4QixJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztJQUM1QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBSSxzQkFBc0IsS0FBYSxPQUFPLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLENBQUM7SUFFN0UsSUFBWSxpQkFBaUI7UUFDNUIsUUFBUSxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQzNCLEtBQUssZ0NBQXNCLENBQUMsV0FBVztnQkFDdEMsT0FBTyxRQUFRLENBQUM7WUFFakIsS0FBSyxnQ0FBc0IsQ0FBQyxVQUFVO2dCQUNyQyxPQUFPLFdBQVcsQ0FBQztZQUVwQixLQUFLLGdDQUFzQixDQUFDLFNBQVM7Z0JBQ3BDLE9BQU8sUUFBUSxDQUFDO1lBRWpCO2dCQUNDLE9BQU8sV0FBVyxDQUFDO1NBQ3BCO0lBQ0YsQ0FBQztJQUVPLGNBQWMsQ0FBQyxlQUFlLEdBQUcsS0FBSztRQUM3QyxJQUFJLENBQUMsSUFBSSxDQUFDLHFCQUFxQixFQUFFO1lBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQUMsd0NBQXdDLENBQUMsQ0FBQztTQUMxRDtRQUVELElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFO1lBQzFCLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztTQUNuRDtRQUVELElBQUksZUFBZSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNyQyxNQUFNLElBQUksS0FBSyxDQUFDLCtDQUErQyxDQUFDLENBQUM7U0FDakU7SUFDRixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FtRUc7SUFDSCxLQUFLLENBQUMsb0JBQW9CLENBQUMsT0FBZ0Q7UUFDMUUsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUU7WUFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxtSEFBbUgsQ0FBQyxDQUFDO1NBQ3JJO1FBRUQsSUFBSSxDQUFDLHFCQUFxQixHQUFHLEtBQUssQ0FBQztRQUNuQyxJQUFJLENBQUMsZUFBZSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUM7UUFFOUMsSUFBSSxPQUFPLE9BQU8sQ0FBQyxzQkFBc0IsSUFBSSxRQUFRLEVBQUU7WUFDdEQsSUFBSSxDQUFDLHVCQUF1QixHQUFHLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQztTQUM5RDtRQUVELElBQUksZ0JBQWdCLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUVsRyxJQUFJLENBQUMscUJBQXFCLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLDJCQUEyQixDQUFDO1lBQzVFLFdBQVcsRUFBRSxPQUFPLENBQUMsV0FBVztZQUNoQyxHQUFHLGdCQUFnQjtZQUNuQixXQUFXLEVBQUUsT0FBTyxDQUFDLFdBQVcsSUFBSSw2QkFBbUIsQ0FBQyxVQUFVO1lBQ2xFLFlBQVksRUFBRSxJQUFJLENBQUMsYUFBYTtZQUNoQyxpRkFBaUY7WUFDakYsc0JBQXNCLEVBQUUsT0FBTyxDQUFDLHNCQUFzQixJQUFJLElBQUksQ0FBQyxzQkFBc0I7U0FDckYsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFFekUsT0FBTyxNQUFNLElBQUksQ0FBQyw0QkFBNEIsRUFBRSxDQUFDO0lBQ2xELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7OztPQWdCRztJQUNILEtBQUssQ0FBQyxXQUFXO1FBQ2hCLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFO1lBQy9CLE1BQU0sSUFBSSxLQUFLLENBQUMsbUhBQW1ILENBQUMsQ0FBQztTQUNySTtRQUVELElBQUksQ0FBQyxxQkFBcUIsR0FBRyxLQUFLLENBQUM7UUFFbkMsSUFBSSxDQUFDLHFCQUFxQixHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBRXRFLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLDJCQUEyQixFQUFFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1FBRTVFLE9BQU8sTUFBTSxJQUFJLENBQUMsNEJBQTRCLEVBQUUsQ0FBQztJQUNsRCxDQUFDO0lBRU8sS0FBSyxDQUFDLDRCQUE0QjtRQUN6QyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO1FBRTlCLElBQUksWUFBWSxHQUFxQyxFQUFFLENBQUM7UUFFeEQsS0FBSyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMscUJBQXFCLENBQUMsb0JBQW9CLEVBQUU7WUFDOUQsUUFBUSxDQUFDLENBQUMsSUFBSSxFQUFFO2dCQUNmLEtBQUssK0JBQXFCLENBQUMsSUFBSTtvQkFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztvQkFDeEMsNkZBQTZGO29CQUM3RixZQUFZLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7b0JBQ25DLE9BQU8sRUFBQyxjQUFjLEVBQUUsS0FBSyxFQUFDLENBQUM7Z0JBRWhDLEtBQUssK0JBQXFCLENBQUMsU0FBUyxDQUFDO2dCQUNyQyxLQUFLLCtCQUFxQixDQUFDLFVBQVU7b0JBQ3BDLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksK0JBQXFCLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQztvQkFDOUUsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsR0FBRyxRQUFRLGdCQUFnQixDQUFDLENBQUM7b0JBRWhELElBQUksVUFBVSxHQUFHLE1BQU0sQ0FBQyxRQUFRLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUMsQ0FBQztvQkFDMUcsSUFBSSxVQUFVLEVBQUU7d0JBQ2YsbURBQW1EO3dCQUNuRCxPQUFPLEVBQUMsY0FBYyxFQUFFLEtBQUssRUFBQyxDQUFDO3FCQUMvQjt5QkFBTTt3QkFDTiwrQkFBK0I7d0JBQy9CLElBQUksTUFBTSxHQUFtQyxFQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFDLENBQUM7d0JBQzVELElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRTs0QkFDZCxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUM7eUJBQzFCO3dCQUNELFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7d0JBQzFCLE1BQU07cUJBQ047Z0JBRUYsS0FBSywrQkFBcUIsQ0FBQyxrQkFBa0IsQ0FBQztnQkFDOUMsS0FBSywrQkFBcUIsQ0FBQyxpQkFBaUI7b0JBQzNDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLDZDQUE2QyxDQUFDLENBQUM7b0JBQ2xFLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBQyxDQUFDLENBQUM7b0JBQ2xDLFlBQVksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztvQkFDbkMsTUFBTTtnQkFFUCxLQUFLLCtCQUFxQixDQUFDLFlBQVk7b0JBQ3RDLGlFQUFpRTtvQkFDakUsTUFBTTtnQkFFUDtvQkFDQyxJQUFJLGVBQWUsR0FBVSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO29CQUMvQyxLQUFLLElBQUksQ0FBQyxJQUFJLCtCQUFxQixFQUFFO3dCQUNwQyxJQUFJLCtCQUFxQixDQUFDLENBQUMsQ0FBQyxJQUFJLGVBQWUsRUFBRTs0QkFDaEQsZUFBZSxHQUFHLENBQUMsQ0FBQzs0QkFDcEIsTUFBTTt5QkFDTjtxQkFDRDtvQkFFRCxNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO2FBQ3ZFO1NBQ0Q7UUFFRCxvRUFBb0U7UUFDcEUsSUFBSSxZQUFZLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtZQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLDJFQUEyRSxDQUFDLENBQUM7U0FDN0Y7UUFFRCxJQUFJLFFBQVEsR0FBd0I7WUFDbkMsY0FBYyxFQUFFLElBQUk7WUFDcEIsWUFBWTtTQUNaLENBQUM7UUFFRixJQUFLLElBQUksQ0FBQyxxQkFBd0QsQ0FBQyxZQUFZLEVBQUU7WUFDaEYsSUFBSSxvQkFBb0IsR0FBa0MsSUFBSSxDQUFDLHFCQUF1RCxDQUFDO1lBQ3ZILFFBQVEsQ0FBQyxjQUFjLEdBQUcsb0JBQW9CLENBQUMsWUFBWSxDQUFDO1NBQzVEO1FBRUQsT0FBTyxRQUFRLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsU0FBUztRQUNSLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUV0QixJQUFJLENBQUMsSUFBSSxDQUFDLG1CQUFtQixFQUFFO1lBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQztTQUMvQztRQUVELElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNoQixDQUFDO0lBRU8sS0FBSyxDQUFDLE9BQU87UUFDcEIsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFDMUIsT0FBTztTQUNQO1FBRUQsc0VBQXNFO1FBQ3RFLFlBQVksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsRUFBRTtZQUM5QixJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ3RDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDckI7UUFFRCxJQUFJLGdCQUFnQixHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUM7UUFDN0QsSUFBSSxnQkFBZ0IsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQzFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDckIsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7WUFDMUIsT0FBTztTQUNQO1FBRUQsSUFBSSxZQUFZLENBQUM7UUFDakIsSUFBSTtZQUNILFlBQVksR0FBRyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1lBQy9FLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxZQUFZLENBQUMsQ0FBQztTQUNsRDtRQUFDLE9BQU8sRUFBRSxFQUFFO1lBQ1osMkVBQTJFO1lBQzNFLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7Z0JBQzNCLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUN2QixJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQzthQUMxQjtZQUNELE9BQU87U0FDUDtRQUVELElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLEdBQUcsWUFBWSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMscUJBQXFCLENBQUMsUUFBUSxDQUFDO1FBRXRHLElBQUksWUFBWSxDQUFDLG9CQUFvQixJQUFJLENBQUMsSUFBSSxDQUFDLHFCQUFxQixFQUFFO1lBQ3JFLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxJQUFJLENBQUM7WUFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQy9CO1FBRUQsSUFBSSxZQUFZLENBQUMsd0JBQXdCLEVBQUU7WUFDMUMsSUFBSSxDQUFDLHVCQUF1QixHQUFHLFlBQVksQ0FBQyx3QkFBd0IsQ0FBQztZQUNyRSxJQUFJLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLENBQUM7U0FDcEM7UUFFRCxJQUFJLFlBQVksQ0FBQyxZQUFZLEVBQUU7WUFDOUIsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUMsV0FBVyxDQUFDO1lBQzdDLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDLFlBQVksQ0FBQztZQUM5QyxJQUFJLENBQUMsV0FBVyxHQUFHLFlBQVksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDO1lBRXBELGdIQUFnSDtZQUNoSCw2R0FBNkc7WUFDN0csVUFBVTtZQUNWLHFGQUFxRjtZQUVyRiw2R0FBNkc7WUFDN0csMkdBQTJHO1lBQzNHLDJHQUEyRztZQUMzRyxZQUFZO1lBQ1osSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLGFBQWEsSUFBSSxnQ0FBc0IsQ0FBQyxTQUFTLEVBQUU7Z0JBQ2hGLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7YUFDaEM7WUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQzNCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1NBQzFCO2FBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUNsQyxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsQ0FBQztTQUNuRztJQUNGLENBQUM7SUFFRDs7T0FFRztJQUNLLEtBQUssQ0FBQyxxQkFBcUI7UUFDbEMsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3pCLElBQUk7Z0JBQ0gsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO2dCQUN0RCxPQUFPLElBQUksQ0FBQzthQUNaO1lBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQ1osSUFBSSxFQUFFLENBQUMsT0FBTyxJQUFJLGlCQUFPLENBQUMsb0JBQW9CLEVBQUU7b0JBQy9DLHVDQUF1QztvQkFDdkMsTUFBTSxFQUFFLENBQUM7aUJBQ1Q7YUFDRDtTQUNEO1FBRUQsbUNBQW1DO1FBQ25DLElBQ0MsSUFBSSxDQUFDLGFBQWEsSUFBSSxnQ0FBc0IsQ0FBQyxVQUFVO2VBQ3BELElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLCtCQUFxQixDQUFDLFlBQVksQ0FBQyxFQUN6RztZQUNELElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQywrQkFBK0IsQ0FBQztnQkFDaEUsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLHNCQUFzQjtnQkFDN0MsR0FBSSxJQUFJLENBQUMscUJBQWlFO2FBQzFFLENBQUMsQ0FBQztZQUVILElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLGdDQUFnQyxpQkFBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7WUFFN0UsSUFBSSxNQUFNLENBQUMsTUFBTSxJQUFJLGlCQUFPLENBQUMsRUFBRSxFQUFFO2dCQUNoQyx5QkFBeUI7Z0JBQ3pCLFlBQVksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztnQkFDbkMsT0FBTyxJQUFJLENBQUM7YUFDWjtTQUNEO1FBRUQsb0JBQW9CO1FBQ3BCLE9BQU8sS0FBSyxDQUFDO0lBQ2QsQ0FBQztJQUVPLEtBQUssQ0FBQyxvQkFBb0I7UUFDakMsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3pCLElBQUk7Z0JBQ0gsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO2dCQUN0RCxPQUFPLElBQUksQ0FBQyxDQUFDLDRCQUE0QjthQUN6QztZQUFDLE9BQU8sRUFBRSxFQUFFO2dCQUNaLElBQUksRUFBRSxDQUFDLE9BQU8sSUFBSSxpQkFBTyxDQUFDLHFCQUFxQixFQUFFO29CQUNoRCx1Q0FBdUM7b0JBQ3ZDLE1BQU0sRUFBRSxDQUFDO2lCQUNUO2FBQ0Q7U0FDRDtRQUVELHlEQUF5RDtRQUN6RCxPQUFPLEtBQUssQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQkc7SUFDSCxLQUFLLENBQUMsb0JBQW9CLENBQUMsUUFBZ0I7UUFDMUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUUxQixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUU1RCxJQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSwrQkFBcUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMxSCxJQUFJLGFBQWEsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSwrQkFBcUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMxSCxJQUFJLENBQUMsY0FBYyxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3RDLE1BQU0sSUFBSSxLQUFLLENBQUMsc0RBQXNELENBQUMsQ0FBQztTQUN4RTtRQUVELE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQztZQUN4QyxHQUFJLElBQUksQ0FBQyxxQkFBaUU7WUFDMUUsUUFBUTtZQUNSLFlBQVksRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLCtCQUFxQixDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsK0JBQXFCLENBQUMsVUFBVTtTQUNqRyxDQUFDLENBQUM7UUFFSCxZQUFZLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsa0JBQWtCO1FBQ2pCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7UUFDN0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUV0QixJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDcEIsWUFBWSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUM5QixPQUFPLElBQUksQ0FBQztTQUNaO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FzQkc7SUFDSCxLQUFLLENBQUMsYUFBYTtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7U0FDbEU7UUFFRCxJQUFJLFNBQVMsR0FBRyxJQUFBLG9CQUFXLEVBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRWhELG1HQUFtRztRQUNuRyxpSEFBaUg7UUFDakgsaUNBQWlDO1FBQ2pDLElBQUksQ0FBQyxnQ0FBc0IsQ0FBQyxXQUFXLEVBQUUsZ0NBQXNCLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUN4RyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsSUFBSSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRTtnQkFDMUYsNkdBQTZHO2dCQUM3Ryx1R0FBdUc7Z0JBQ3ZHLHdHQUF3RztnQkFDeEcsTUFBTSxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQzthQUNoQztZQUVELElBQUksV0FBVyxHQUFHLGtCQUFrQixDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDakcsT0FBTyxDQUFDLG9CQUFvQixXQUFXLEVBQUUsRUFBRSxhQUFhLFNBQVMsRUFBRSxDQUFDLENBQUM7U0FDckU7UUFFRCxJQUFJLElBQUksR0FBRztZQUNWLEtBQUssRUFBRSxJQUFJLENBQUMsWUFBWTtZQUN4QixTQUFTLEVBQUUsU0FBUztZQUNwQixLQUFLLEVBQUUsOENBQThDO1NBQ3JELENBQUM7UUFFRixLQUFLLENBQUMsMERBQTBELEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDeEUsSUFBSSxnQkFBZ0IsR0FBRyxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDO1lBQ3BELE1BQU0sRUFBRSxNQUFNO1lBQ2QsR0FBRyxFQUFFLGtEQUFrRDtZQUN2RCxPQUFPLEVBQUUscUJBQVc7WUFDcEIsYUFBYSxFQUFFLGlCQUFVLENBQUMsMkJBQTJCLENBQUMsSUFBSSxDQUFDO1NBQzNELENBQUMsQ0FBQztRQUVILElBQUksZ0JBQWdCLENBQUMsUUFBUSxJQUFJLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUU7WUFDakUsTUFBTSxJQUFBLHNCQUFZLEVBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3BEO1FBRUQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxhQUFhLEVBQUU7WUFDM0UsSUFBSSxHQUFHLEdBQU8sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQztZQUNwRCxHQUFHLENBQUMsWUFBWSxHQUFHLGdCQUFnQixDQUFDLFFBQVEsQ0FBQztZQUM3QyxNQUFNLEdBQUcsQ0FBQztTQUNWO1FBRUQsNkdBQTZHO1FBQzdHLGlIQUFpSDtRQUNqSCx1Q0FBdUM7UUFDdkMsSUFBSSxTQUFTLEdBQXVCLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBQyxHQUFHLEVBQUUsTUFBTSxFQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksT0FBTyxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFDeEksSUFBSSxJQUFJLEdBQUcsRUFBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsRUFBRSxHQUFHLE1BQU0sRUFBQyxDQUFDO1lBQzdELEtBQUssQ0FBQyxZQUFZLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBRS9CLElBQUksTUFBb0IsQ0FBQztZQUN6QixJQUFJO2dCQUNILE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDO29CQUN0QyxNQUFNLEVBQUUsTUFBTTtvQkFDZCxHQUFHO29CQUNILGFBQWEsRUFBRSxpQkFBVSxDQUFDLDJCQUEyQixDQUFDLElBQUksQ0FBQztpQkFDM0QsQ0FBQyxDQUFDO2FBQ0g7WUFBQyxPQUFPLEtBQUssRUFBRTtnQkFDZixPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNyQjtZQUVELElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7Z0JBQ2pHLE9BQU8sTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUMsQ0FBQzthQUMzRDtZQUVELElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxFQUFFO2dCQUMvRSxPQUFPLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDLENBQUM7YUFDakU7WUFFRCxJQUFJLE1BQU0sR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDL0IsT0FBTyxDQUNOLE1BQU0sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUMvQixNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLFlBQVksTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FDNUYsQ0FDRCxDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVKLElBQUksT0FBTyxHQUFZLEVBQUUsQ0FBQztRQUMxQixDQUFDLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLGFBQWEsRUFBRSxFQUFFO1lBQ3hELE9BQU8sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3pDLENBQUMsQ0FBQyxDQUFDO1FBRUgscUdBQXFHO1FBQ3JHLE9BQU8sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7UUFFM0QsZ0NBQWdDO1FBQ2hDLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxTQUFTLEVBQUUsQ0FBQyxDQUFDO1FBRXZDLE9BQU8sT0FBTyxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXlCRztJQUNILEtBQUssQ0FBQyxrQkFBa0I7UUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO1NBQ3pFO1FBRUQsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7SUFDbkcsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNILEtBQUssQ0FBQyxpQkFBaUI7UUFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO1NBQ3pFO1FBRUQsSUFBSSxFQUFDLFdBQVcsRUFBRSxZQUFZLEVBQUMsR0FBRyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN6RyxJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztRQUMvQixJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDO1FBRXRELE9BQU8sQ0FBQyxDQUFDLFlBQVksQ0FBQztJQUN2QixDQUFDOztBQS8yQkYsK0JBazhCQztBQWpGQSw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUU1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JHO0FBQ0ksb0JBQU8sR0FBRyxTQUFTLENBQUM7QUFFM0I7Ozs7O0dBS0c7QUFDSSxvQkFBTyxHQUFHLFNBQVMsQ0FBQztBQUUzQjs7Ozs7O0dBTUc7QUFDSSw4QkFBaUIsR0FBRyxtQkFBbUIsQ0FBQztBQUUvQzs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSSxtQ0FBc0IsR0FBRyx3QkFBd0IsQ0FBQztBQUV6RDs7Ozs7O0dBTUc7QUFDSSwwQkFBYSxHQUFHLGVBQWUsQ0FBQztBQUV2Qzs7Ozs7Ozs7Ozs7OztHQWFHO0FBQ0ksa0JBQUssR0FBRyxPQUFPLENBQUMifQ==