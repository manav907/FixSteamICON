import SteamID from 'steamid';
import { TypedEmitter } from 'tiny-typed-emitter';
import { ConstructorOptions, StartLoginSessionWithCredentialsDetails, StartSessionResponse } from './interfaces-external';
import EAuthTokenPlatformType from './enums-steam/EAuthTokenPlatformType';
/**
 * Unfortunately, IDE intellisense and the typedoc generator have two different means of defining events.
 * So, if an event is added, you need to add it both here and at the bottom of LoginSession as a static property.
 */
interface LoginSessionEvents {
    debug: (...any: any[]) => void;
    'debug-handler': (...any: any[]) => void;
    polling: () => void;
    authenticated: () => void;
    timeout: () => void;
    error: (Error: any) => void;
    remoteInteraction: () => void;
    steamGuardMachineToken: () => void;
}
/**
 * Using CommonJS:
 * ```js
 * const {LoginSession} = require('steam-session');
 * ```
 *
 * Using ES6 modules:
 * ```js
 * import {LoginSession} from 'steam-session';
 * ```
 *
 * The {@link LoginSession} class is the primary way to interact with steam-session.
 *
 * @see Example: [login-with-password.ts](https://github.com/DoctorMcKay/node-steam-session/blob/master/examples/login-with-password.ts)
 * @see Example: [login-with-qr.ts](https://github.com/DoctorMcKay/node-steam-session/blob/master/examples/login-with-qr.ts)
 */
export default class LoginSession extends TypedEmitter<LoginSessionEvents> {
    private _loginTimeout;
    private _accountName?;
    private _accessToken?;
    private _refreshToken?;
    private _platformType;
    private _webClient;
    private _handler;
    private _steamGuardCode?;
    private _steamGuardMachineToken?;
    private _startSessionResponse?;
    private _hadRemoteInteraction?;
    private _pollingStartedTime?;
    private _pollTimer?;
    private _pollingCanceled?;
    private _accessTokenSetAt?;
    /**
     * @param {EAuthTokenPlatformType} platformType - A value from {@link EAuthTokenPlatformType}.
     * You should set this to the appropriate platform type for your desired usage.
     * @param {ConstructorOptions} [options]
     * @return
     *
     * Constructs a new `LoginSession` instance. Example usage:
     *
     * ```js
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let session = new LoginSession(EAuthTokenPlatformType.WebBrowser);
     * ```
     */
    constructor(platformType: EAuthTokenPlatformType, options?: ConstructorOptions);
    /**
     * A `number` specifying the time, in milliseconds, before a login attempt will {@link timeout}. The timer begins
     * after {@link polling} begins.
     *
     * If you attempt to set this property after {@link polling} has already been emitted, an Error will be thrown since
     * setting this property after that point has no effect.
     */
    get loginTimeout(): number;
    set loginTimeout(value: number);
    /**
     * **Read-only.** A [`SteamID`](https://www.npmjs.com/package/steamid) instance containing the SteamID for the
     * currently-authenticated account. Populated immediately after {@link startWithCredentials}
     * resolves, or immediately after {@link accessToken} or {@link refreshToken} are set (meaning that
     * this is always populated when {@link authenticated} fires).
     */
    get steamID(): SteamID;
    /**
     * **Read-only.** A `string` containing your account name. This is populated just before the {@link authenticated}
     * event is fired.
     */
    get accountName(): string;
    /**
     * A `string` containing your access token. As of 2023-09-12, Steam does not return an access token in response to
     * successful authentication, so this won't be set when the {@link authenticated} event is fired. This will be set
     * after you call {@link refreshAccessToken} or {@link renewRefreshToken}. Also, since {@link getWebCookies} calls
     * {@link refreshAccessToken} internally for {@link EAuthTokenPlatformType.SteamClient | EAuthTokenPlatformType.SteamClient}
     * or {@link EAuthTokenPlatformType.MobileApp | MobileApp}, this will also be set after calling {@link getWebCookies}
     * for those platform types.
     *
     * You can also assign an access token to this property if you already have one, although at present that wouldn't
     * do anything useful.
     *
     * Setting this property will throw an Error if:
     *
     * - You set it to a token that isn't well-formed, or
     * - You set it to a refresh token rather than an access token, or
     * - You have already called {@link startWithCredentials} and you set it to a token that doesn't belong to the same account, or
     * - You have already set {@link refreshToken} and you set this to a token that doesn't belong to the same account as the refresh token
     *
     * Access tokens can't be used for much. You can use them with a few undocumented WebAPIs like
     * [IFriendsListService/GetFriendsList](https://steamapi.xpaw.me/#IFriendsListService/GetFriendsList) by passing the access
     * token as an access_token query string parameter. For example:
     *
     *     https://api.steampowered.com/IFriendsListService/GetFriendsList/v1/?access_token=eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...
     *
     * As of time of writing (2023-04-24), it appears that you can also use access tokens with regular published API methods,
     * for example:
     *
     *     https://api.steampowered.com/ISteamUserStats/GetNumberOfCurrentPlayers/v1/?appid=440&access_token=eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...
     *
     * node-steamcommunity also has a method you can use to provide it with an access token:
     * [`setMobileAppAccessToken`](https://github.com/DoctorMcKay/node-steamcommunity/wiki/SteamCommunity#setmobileappaccesstokenaccesstoken)
     */
    get accessToken(): string;
    set accessToken(token: string);
    /**
     * A `string` containing your refresh token. This is populated just before the {@link authenticated} event is fired.
     * You can also assign a refresh token to this property if you already have one.
     *
     * Setting this property will throw an Error if:
     *
     * - You set it to a token that isn't well-formed, or
     * - You set it to an access token rather than a refresh token, or
     * - You have already called {@link startWithCredentials} and you set it to a token that doesn't belong to the same account, or
     * - You have already set {@link accessToken} and you set this to a token that doesn't belong to the same account as the access token
     */
    get refreshToken(): string;
    set refreshToken(token: string);
    /**
     * **Read-only.** A `string` containing your Steam Guard machine token. This is populated when you pass a `steamGuardMachineToken` to
     * {@link startWithCredentials}, or just before the {@link steamGuardMachineToken} event is emitted.
     */
    get steamGuardMachineToken(): string;
    private get _defaultWebsiteId();
    private _verifyStarted;
    /**
     * @param details
     * @return
     *
     * Starts a new login attempt using your account credentials. Returns a Promise.
     *
     * If you're logging in with {@link EAuthTokenPlatformType.SteamClient | EAuthTokenPlatformType.SteamClient}, you
     * can supply a Buffer containing the SHA-1 hash of your sentry file for
     * {@link StartLoginSessionWithCredentialsDetails.steamGuardMachineToken}.
     *
     * For example:
     *
     *
     * ```js
     * import {createHash} from 'crypto';
     * import {readFileSync} from 'fs';
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let hash = createHash('sha1');
     * hash.update(readFileSync('ssfn1234567890'));
     * let buffer = hash.digest(); // buffer contains a Buffer
     *
     * let session = new LoginSession(EAuthTokenPlatformType.SteamClient);
     * session.startWithCredentials({
     *     accountName: 'johndoe',
     *     password: 'h3ll0wor1d',
     *     steamGuardMachineToken: buffer
     * });
     * ```
     *
     * If you supply a {@link StartLoginSessionWithCredentialsDetails.steamGuardCode} here and you're using email-based
     * Steam Guard, Steam will send you a new Steam Guard email if you're using {@link EAuthTokenPlatformType.SteamClient | EAuthTokenPlatformType.SteamClient}
     * or {@link EAuthTokenPlatformType.MobileApp}. You would ideally keep your LoginSession active that generated your
     * first email, and pass the code using {@link submitSteamGuardCode} instead of creating a new LoginSession and
     * supplying the code to {@link startWithCredentials}.
     *
     * On failure, the Promise will be rejected with its message being equal to the string representation of an {@link EResult}
     * value. There will also be an `eresult` property on the Error object equal to the numeric representation of the relevant
     * EResult value. For example:
     *
     * ```
     * Error: InvalidPassword
     *   eresult: 5
     * ```
     *
     * On success, the Promise will be resolved with a {@link StartSessionResponse} object.
     *
     * Here's a list of which guard types might be present in this method's response, and how you should proceed:
     *
     * - {@link EAuthSessionGuardType.EmailCode}: An email was sent to you containing a code
     *   (`detail` contains your email address' domain, e.g. `gmail.com`).
     *   You should get that code and either call {@link submitSteamGuardCode}, or create a new {@link LoginSession}
     *   and supply that code to the {@link StartLoginSessionWithCredentialsDetails.steamGuardCode} property when calling
     *   {@link startWithCredentials}.
     * - {@link EAuthSessionGuardType.DeviceCode}: You need to supply a TOTP code from your mobile authenticator
     *   (or by using [steam-totp](https://www.npmjs.com/package/steam-totp)).
     *   Get that code and either call {@link submitSteamGuardCode}, or create a new {@link LoginSession} and supply that
     *   code to the {@link StartLoginSessionWithCredentialsDetails.steamGuardCode} property when calling {@link startWithCredentials}.
     * - {@link EAuthSessionGuardType.DeviceConfirmation}: You need to approve the confirmation prompt in your Steam
     *   mobile app. If this guard type is present, {@link polling} will start and {@link loginTimeout} will be in effect.
     * - {@link EAuthSessionGuardType.EmailConfirmation}: You need to approve the confirmation email sent to you. If this
     *   guard type is present, {@link polling} will start and {@link loginTimeout} will be in effect.
     *
     * Note that multiple guard types might be available; for example both {@link EAuthSessionGuardType.DeviceCode} and
     * {@link EAuthSessionGuardType.DeviceConfirmation} can be available at the same time.
     *
     * When this method resolves, {@link steamID} will be populated.
     */
    startWithCredentials(details: StartLoginSessionWithCredentialsDetails): Promise<StartSessionResponse>;
    /**
     * @return
     *
     * Starts a new QR login attempt. Returns a Promise.
     *
     * On failure, the Promise will be rejected with its message being equal to the string representation of an {@link EResult}
     * value. There will also be an `eresult` property on the Error object equal to the numeric representation of the relevant
     * EResult value. Realistically, failures should never happen unless Steam is having problems or you're having network issues.
     *
     * On success, the Promise will be resolved with a {@link StartSessionResponse} object.
     *
     * {@link steamID} will not be populated when this method resolves, since at this point we don't know which account
     * we're going to log into. It will be populated after you successfully {@link authenticated | authenticate}.
     *
     * Immediately after this resolves, {@link LoginSession} will start {@link polling} to determine when authentication
     * has succeeded.
     */
    startWithQR(): Promise<StartSessionResponse>;
    private _processStartSessionResponse;
    /**
     * @return
     *
     * Forces an immediate polling attempt. This will throw an `Error` if you call it before the {@link polling} event is
     * emitted, after {@link authenticated} is emitted, or after you call {@link cancelLoginAttempt}.
     */
    forcePoll(): void;
    private _doPoll;
    /**
     * @returns {boolean} - true if code submitted successfully, false if code wasn't valid or no code available
     */
    private _attemptEmailCodeAuth;
    private _attemptTotpCodeAuth;
    /**
     * @param authCode - Your Steam Guard code
     * @return
     *
     * If a Steam Guard code is needed, you can supply it using this method. Returns a Promise.
     *
     * On failure, the Promise will be rejected with its message being equal to the string representation of an {@link EResult}
     * value. There will also be an `eresult` property on the Error object equal to the numeric representation of the relevant
     * EResult value. For example:
     *
     * ```
     * Error: TwoFactorCodeMismatch
     *   eresult: 88
     * ```
     *
     * Note that an incorrect email code will fail with EResult value {@link EResult.InvalidLoginAuthCode} (65), and an
     * incorrect TOTP code will fail with EResult value {@link EResult.TwoFactorCodeMismatch} (88).
     *
     * On success, the Promise will be resolved with no value. In this case, you should expect for {@link authenticated}
     * to be emitted shortly.
     */
    submitSteamGuardCode(authCode: string): Promise<void>;
    /**
     * @return - True if we were actively polling and it has now been canceled. False if we were not polling.
     *
     * Cancels {@link polling} for an ongoing login attempt. Once canceled, you should no longer interact with this
     * {@link LoginSession} object, and you should create a new one if you want to start a new attempt.
     */
    cancelLoginAttempt(): boolean;
    /**
     * @return
     *
     * Once successfully {@link authenticated}, you can call this method to get cookies for use on the Steam websites.
     * You can also manually set {@link refreshToken} and then call this method without going through another login
     * attempt if you already have a valid refresh token. Returns a Promise.
     *
     * On failure, the Promise will be rejected. Depending on the nature of the failure, an {@link EResult} may or may
     * not be available.
     *
     * On success, the Promise will be resolved with an array of strings. Each string contains a cookie, e.g.
     * `'steamLoginSecure=blahblahblahblah'`.
     *
     * Here's an example of how you can get new web cookies when you already have a valid refresh token:
     *
     * ```js
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let session = new LoginSession(EAuthTokenPlatformType.WebBrowser);
     * session.refreshToken = 'eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...';
     * let cookies = await session.getWebCookies();
     * ```
     */
    getWebCookies(): Promise<string[]>;
    /**
     * @return
     *
     * As long as a {@link refreshToken} is set, you can call this method to obtain a new access token.
     * Returns a Promise.
     *
     * On failure, the Promise will be rejected. An {@link EResult} will be available under the `eresult` property of
     * the Error object.
     *
     * On success, the Promise will be resolved with no value. You can then read the access token from the LoginSession's
     * {@link accessToken} property.
     *
     * ```js
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let session = new LoginSession(EAuthTokenPlatformType.WebBrowser);
     * session.refreshToken = 'eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...';
     * await session.refreshAccessToken();
     *
     * console.log(`New access token: ${session.accessToken}`);
     * ```
     *
     * As of 2023-04-24, this method works for {@link EAuthTokenPlatformType.MobileApp | EAuthTokenPlatformType.MobileApp}
     * and {@link EAuthTokenPlatformType.SteamClient}, but using {@link EAuthTokenPlatformType.WebBrowser} will fail
     * with response {@link EResult.AccessDenied}.
     */
    refreshAccessToken(): Promise<void>;
    /**
     * @return boolean
     *
     * Does the same thing as {@link refreshAccessToken}, while also attempting to renew your refresh token.
     *
     * Whether a new refresh token will actually be issued is at the discretion of the Steam backend. This method will
     * return true if a new refresh token was issued (which can be accessed using the {@link refreshToken} property), or
     * false if no new refresh token was issued. Regardless of the return value, the {@link accessToken} property is
     * always updated with a fresh access token (unless there was an error).
     *
     * **Important:** If a refresh token is successfully renewed (e.g. this method returns true), the old refresh token
     * will become invalid, even if it is not yet expired.
     */
    renewRefreshToken(): Promise<boolean>;
    /**
     * This event is emitted once we start polling Steam to periodically check if the login attempt has succeeded or not.
     * Polling starts when any of these conditions are met:
     *
     * - A login session is successfully started with credentials and no guard is required (e.g. Steam Guard is disabled)*
     * - A login session is successfully started with credentials and you supplied a valid code to {@link StartLoginSessionWithCredentialsDetails.steamGuardCode}*
     * - A login session is successfully started with credentials, you're using email Steam Guard, and you supplied a valid {@link StartLoginSessionWithCredentialsDetails.steamGuardMachineToken}*
     * - A login session is successfully started with credentials, then you supplied a valid code to {@link submitSteamGuardCode}*
     * - A login session is successfully started, and {@link EAuthSessionGuardType.DeviceConfirmation} or {@link EAuthSessionGuardType.EmailConfirmation} are among the valid guards
     * 	 - This case covers {@link startWithQR | QR logins}, since a QR login is a device confirmation under the hood
     *
     * \* = in these cases, we expect to only have to poll once before login succeeds.
     *
     * After this event is emitted, if your {@link loginTimeout} elapses and the login attempt has not yet succeeded,
     * {@link timeout} is emitted and the login attempt is abandoned. You would then need to start a new login attempt
     * using a fresh {@link LoginSession} object.
     *
     * @event
     */
    static polling: string;
    /**
     * This event is emitted when the time specified by {@link loginTimeout} elapses after {@link polling} begins, and
     * the login attempt has not yet succeeded. When `timeout` is emitted, {@link cancelLoginAttempt} is called internally.
     *
     * @event
     */
    static timeout: string;
    /**
     * This event is emitted when Steam reports a "remote interaction" via {@link polling}. This is observed to happen
     * when the approval prompt is viewed in the Steam mobile app for the {@link EAuthSessionGuardType.DeviceConfirmation}
     * guard. For a {@link startWithQR | QR login}, this would be after you scan the code, but before you tap approve or deny.
     *
     * @event
     */
    static remoteInteraction: string;
    /**
     * This event is emitted when Steam sends us a new Steam Guard machine token. Machine tokens are only relevant when logging
     * into an account that has email-based Steam Guard enabled. Thus, this will only be emitted after successfully logging into
     * such an account.
     *
     * At this time, this event is only emitted when logging in using {@link EAuthTokenPlatformType.SteamClient | EAuthTokenPlatformType.SteamClient}.
     * It's not presently possible to get a machine token for the {@link EAuthTokenPlatformType.WebBrowser} platform
     * (and {@link EAuthTokenPlatformType.MobileApp} platform doesn't support machine tokens at all).
     *
     * When this event is emitted, the {@link LoginSession#steamGuardMachineToken} property contains your new machine token.
     *
     * @event
     */
    static steamGuardMachineToken: string;
    /**
     * This event is emitted when we successfully authenticate with Steam. At this point, {@link accountName}
     * and {@link refreshToken} are populated. If the {@link EAuthTokenPlatformType}
     * passed to the {@link constructor} is appropriate, you can now safely call {@link getWebCookies}.
     *
     * @event
     */
    static authenticated: string;
    /**
     * This event is emitted if we encounter an error while {@link polling}. The first argument to the event handler is
     * an Error object. If this happens, the login attempt has failed and will need to be retried.
     *
     * Node.js will crash if this event is emitted and not handled.
     *
     * ```js
     * session.on('error', (err) => {
     *     console.error(`An error occurred: ${err.message}`);
     * });
     * ```
     *
     * @event
     */
    static error: string;
}
export {};
//# sourceMappingURL=LoginSession.d.ts.map