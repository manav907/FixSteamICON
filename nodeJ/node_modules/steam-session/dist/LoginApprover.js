"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const https_1 = __importDefault(require("https"));
const socks_proxy_agent_1 = require("socks-proxy-agent");
const stdlib_1 = __importDefault(require("@doctormckay/stdlib"));
const http_1 = require("@doctormckay/stdlib/http");
const steamid_1 = __importDefault(require("steamid"));
const AuthenticationClient_1 = __importDefault(require("./AuthenticationClient"));
const WebApiTransport_1 = __importDefault(require("./transports/WebApiTransport"));
const helpers_1 = require("./helpers");
const ESessionPersistence_1 = __importDefault(require("./enums-steam/ESessionPersistence"));
const EAuthTokenPlatformType_1 = __importDefault(require("./enums-steam/EAuthTokenPlatformType"));
/**
 * Using CommonJS:
 * ```js
 * const {LoginApprover} = require('steam-session');
 * ```
 *
 * Using ES6 modules:
 * ```js
 * import {LoginSession} from 'steam-session';
 * ```
 *
 * The {@link LoginApprover} class can be used to approve a login attempt that was started with a QR code.
 *
 * @see Example: [approve-qr.ts](https://github.com/DoctorMcKay/node-steam-session/blob/master/examples/approve-qr.ts)
 */
class LoginApprover {
    /**
     *
     * @param {string} accessToken - A valid access token for the account you want to approve logins for. This access token
     * **(not refresh token)** must have been created using the {@link EAuthTokenPlatformType.MobileApp} platform type.
     * @param {string|Buffer} sharedSecret - Your account's TOTP shared secret. If this is a string, it must be hex- or
     * base64-encoded.
     * @param {ConstructorOptions} [options]
     * @return
     *
     * Constructs a new `LoginApprover` instance. Example usage:
     *
     * ```js
     * import {LoginApprover} from 'steam-session';
     *
     * let approver = new LoginApprover('eyAid...', 'oTVMfZJ9uHXo3m9MwTD9IOEWQaw=');
     * ```
     *
     * An `Error` will be thrown if your `accessToken` isn't a well-formed JWT, if it's a refresh token rather than an
     * access token, or if it's an access token that was not generated using
     * {@link EAuthTokenPlatformType.MobileApp | EAuthTokenPlatformType.MobileApp}.
     */
    constructor(accessToken, sharedSecret, options) {
        options = options || {};
        let mutuallyExclusiveOptions = ['localAddress', 'httpProxy', 'socksProxy', 'agent'];
        if (Object.keys(options).filter(k => mutuallyExclusiveOptions.includes(k)).length > 1) {
            throw new Error('Cannot specify more than one of localAddress, httpProxy, socksProxy, or agent at the same time');
        }
        let agent = options.agent || new https_1.default.Agent({ keepAlive: true });
        if (options.httpProxy) {
            agent = stdlib_1.default.HTTP.getProxyAgent(true, options.httpProxy);
        }
        else if (options.socksProxy) {
            agent = new socks_proxy_agent_1.SocksProxyAgent(options.socksProxy);
        }
        this._webClient = new http_1.HttpClient({
            httpsAgent: agent,
            localAddress: options.localAddress
        });
        this.accessToken = accessToken;
        this.sharedSecret = sharedSecret;
        this._handler = new AuthenticationClient_1.default({
            platformType: EAuthTokenPlatformType_1.default.MobileApp,
            transport: options.transport || new WebApiTransport_1.default(this._webClient),
            webClient: this._webClient,
            webUserAgent: (0, helpers_1.defaultUserAgent)()
        });
    }
    /**
     * **Read-only.** A [SteamID](https://www.npmjs.com/package/steamid) instance containing the SteamID for the account
     * to which the provided {@link accessToken} belongs. Populated immediately after {@link accessToken} is set.
     */
    get steamID() {
        if (this.accessToken) {
            let decodedToken = (0, helpers_1.decodeJwt)(this.accessToken);
            return new steamid_1.default(decodedToken.sub);
        }
        else {
            return null;
        }
    }
    /**
     * A `string` containing your access token. This is automatically set by the constructor, but you can also manually
     * assign it if you need to set a new access token.
     *
     * An `Error` will be thrown when you set this property if you set it to a valid that isn't a well-formed JWT, if
     * it's a refresh token rather than an access token, or if it's an access token that was not generated using
     * {@link EAuthTokenPlatformType.MobileApp | EAuthTokenPlatformType.MobileApp}.
     */
    get accessToken() { return this._accessToken; }
    set accessToken(token) {
        let decoded = (0, helpers_1.decodeJwt)(token);
        let aud = decoded.aud || [];
        // Is it an access token and not a refresh token?
        if (aud.includes('derive')) {
            throw new Error('Provided token is a refresh token, not an access token');
        }
        if (!aud.includes('mobile')) {
            throw new Error('Provided token is not valid for MobileApp platform usage');
        }
        this._accessToken = token;
    }
    get _secretAsBuffer() {
        if (Buffer.isBuffer(this.sharedSecret)) {
            return this.sharedSecret;
        }
        if (this.sharedSecret.match(/^[0-9a-f]{40}$/i)) {
            // Looks like it's hex
            return Buffer.from(this.sharedSecret, 'hex');
        }
        // It must be base64
        return Buffer.from(this.sharedSecret, 'base64');
    }
    /**
     * @param {string} qrChallengeUrl - The QR challenge URL from a {@link steam-session.LoginSession.startWithQR} call
     * @return
     *
     * Retrieves info for an auth session given a QR challenge URL. Once you call this,
     * {@link steam-session.LoginSession.remoteInteraction} will be emitted. If the QR auth session was initiated within
     * a legitimate Steam client or website, a loading indicator will be overlayed on the QR code to indicate that the
     * session is being dealt with on a mobile device.
     */
    async getAuthSessionInfo(qrChallengeUrl) {
        let { clientId } = decodeQrUrl(qrChallengeUrl);
        let result = await this._handler.getAuthSessionInfo(this._accessToken, { clientId });
        return {
            ip: result.ip,
            location: {
                geoloc: result.geoloc,
                city: result.city,
                state: result.state
            },
            platformType: result.platformType,
            deviceFriendlyName: result.deviceFriendlyName,
            version: result.version,
            loginHistory: result.loginHistory,
            locationMismatch: result.locationMismatch,
            highUsageLogin: result.highUsageLogin,
            requestedPersistence: result.requestedPersistence
        };
    }
    /**
     * @param {ApproveAuthSessionRequest} details
     * @return
     *
     * Approves or denies an auth session from a QR URL. If you pass `true` for
     * {@link method-params.ApproveAuthSessionRequest.approve}, then the next poll from the {@link steam-session.LoginSession}
     * will return access tokens. If you pass `false`, then the {@link steam-session.LoginSession} will emit an
     * {@link steam-session.LoginSession.error} event with EResult {@link EResult.FileNotFound}.
     *
     * Returns a Promise which resolves with no value. Once this Promise resolves, you could call
     * {@link steam-session.LoginSession.forcePoll}, and the {@link steam-session.LoginSession} should then immediately
     * emit {@link steam-session.LoginSession.authenticated}.
     */
    async approveAuthSession(details) {
        let { clientId, version } = decodeQrUrl(details.qrChallengeUrl);
        let signatureData = Buffer.alloc(2 + 8 + 8);
        signatureData.writeUInt16LE(version, 0);
        signatureData.writeBigUInt64LE(BigInt(clientId), 2);
        signatureData.writeBigUInt64LE(BigInt(this.steamID), 10);
        let signature = (0, crypto_1.createHmac)('sha256', this._secretAsBuffer)
            .update(signatureData)
            .digest();
        await this._handler.submitMobileConfirmation(this.accessToken, {
            version,
            clientId,
            steamId: this.steamID.getSteamID64(),
            signature,
            confirm: details.approve,
            persistence: details.persistence || ESessionPersistence_1.default.Persistent
        });
    }
}
exports.default = LoginApprover;
function decodeQrUrl(qrUrl) {
    let match = qrUrl.match(/^https?:\/\/s\.team\/q\/(\d+)\/(\d+)(\?|$)/);
    if (!match) {
        throw new Error('Invalid QR code URL');
    }
    return { clientId: match[2], version: parseInt(match[1], 10) };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9naW5BcHByb3Zlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9Mb2dpbkFwcHJvdmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsbUNBQWtDO0FBQ2xDLGtEQUEwQjtBQUMxQix5REFBa0Q7QUFDbEQsaUVBQXlDO0FBQ3pDLG1EQUFvRDtBQUNwRCxzREFBOEI7QUFFOUIsa0ZBQTBEO0FBQzFELG1GQUEyRDtBQUUzRCx1Q0FBc0Q7QUFDdEQsNEZBQW9FO0FBQ3BFLGtHQUEwRTtBQUUxRTs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUNILE1BQXFCLGFBQWE7SUFjakM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0JHO0lBQ0gsWUFBWSxXQUFtQixFQUFFLFlBQTJCLEVBQUUsT0FBNEI7UUFDekYsT0FBTyxHQUFHLE9BQU8sSUFBSSxFQUFFLENBQUM7UUFFeEIsSUFBSSx3QkFBd0IsR0FBRyxDQUFDLGNBQWMsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3BGLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ3RGLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0dBQWdHLENBQUMsQ0FBQztTQUNsSDtRQUVELElBQUksS0FBSyxHQUFlLE9BQU8sQ0FBQyxLQUFLLElBQUksSUFBSSxlQUFLLENBQUMsS0FBSyxDQUFDLEVBQUMsU0FBUyxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7UUFFNUUsSUFBSSxPQUFPLENBQUMsU0FBUyxFQUFFO1lBQ3RCLEtBQUssR0FBRyxnQkFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxTQUFTLENBQWdCLENBQUM7U0FDMUU7YUFBTSxJQUFJLE9BQU8sQ0FBQyxVQUFVLEVBQUU7WUFDOUIsS0FBSyxHQUFHLElBQUksbUNBQWUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDaEQ7UUFFRCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksaUJBQVUsQ0FBQztZQUNoQyxVQUFVLEVBQUUsS0FBSztZQUNqQixZQUFZLEVBQUUsT0FBTyxDQUFDLFlBQVk7U0FDbEMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFDL0IsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFDakMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLDhCQUFvQixDQUFDO1lBQ3hDLFlBQVksRUFBRSxnQ0FBc0IsQ0FBQyxTQUFTO1lBQzlDLFNBQVMsRUFBRSxPQUFPLENBQUMsU0FBUyxJQUFJLElBQUkseUJBQWUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO1lBQ3BFLFNBQVMsRUFBRSxJQUFJLENBQUMsVUFBVTtZQUMxQixZQUFZLEVBQUUsSUFBQSwwQkFBZ0IsR0FBRTtTQUNoQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBSSxPQUFPO1FBQ1YsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ3JCLElBQUksWUFBWSxHQUFHLElBQUEsbUJBQVMsRUFBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDL0MsT0FBTyxJQUFJLGlCQUFPLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3JDO2FBQU07WUFDTixPQUFPLElBQUksQ0FBQztTQUNaO0lBQ0YsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxJQUFJLFdBQVcsS0FBYSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELElBQUksV0FBVyxDQUFDLEtBQWE7UUFDNUIsSUFBSSxPQUFPLEdBQUcsSUFBQSxtQkFBUyxFQUFDLEtBQUssQ0FBQyxDQUFDO1FBQy9CLElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDO1FBRTVCLGlEQUFpRDtRQUNqRCxJQUFJLEdBQUcsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEtBQUssQ0FBQyx3REFBd0QsQ0FBQyxDQUFDO1NBQzFFO1FBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQywwREFBMEQsQ0FBQyxDQUFDO1NBQzVFO1FBRUQsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7SUFDM0IsQ0FBQztJQUVELElBQVksZUFBZTtRQUMxQixJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFO1lBQ3ZDLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztTQUN6QjtRQUVELElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsRUFBRTtZQUMvQyxzQkFBc0I7WUFDdEIsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDN0M7UUFFRCxvQkFBb0I7UUFDcEIsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0gsS0FBSyxDQUFDLGtCQUFrQixDQUFDLGNBQXNCO1FBQzlDLElBQUksRUFBQyxRQUFRLEVBQUMsR0FBRyxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDN0MsSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsRUFBQyxRQUFRLEVBQUMsQ0FBQyxDQUFDO1FBRW5GLE9BQU87WUFDTixFQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUU7WUFDYixRQUFRLEVBQUU7Z0JBQ1QsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNO2dCQUNyQixJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUk7Z0JBQ2pCLEtBQUssRUFBRSxNQUFNLENBQUMsS0FBSzthQUNuQjtZQUNELFlBQVksRUFBRSxNQUFNLENBQUMsWUFBWTtZQUNqQyxrQkFBa0IsRUFBRSxNQUFNLENBQUMsa0JBQWtCO1lBQzdDLE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBTztZQUN2QixZQUFZLEVBQUUsTUFBTSxDQUFDLFlBQVk7WUFDakMsZ0JBQWdCLEVBQUUsTUFBTSxDQUFDLGdCQUFnQjtZQUN6QyxjQUFjLEVBQUUsTUFBTSxDQUFDLGNBQWM7WUFDckMsb0JBQW9CLEVBQUUsTUFBTSxDQUFDLG9CQUFvQjtTQUNqRCxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNILEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxPQUFrQztRQUMxRCxJQUFJLEVBQUMsUUFBUSxFQUFFLE9BQU8sRUFBQyxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7UUFFOUQsSUFBSSxhQUFhLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzVDLGFBQWEsQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3hDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDcEQsYUFBYSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFekQsSUFBSSxTQUFTLEdBQUcsSUFBQSxtQkFBVSxFQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDO2FBQ3hELE1BQU0sQ0FBQyxhQUFhLENBQUM7YUFDckIsTUFBTSxFQUFFLENBQUM7UUFFWCxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUM5RCxPQUFPO1lBQ1AsUUFBUTtZQUNSLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRTtZQUNwQyxTQUFTO1lBQ1QsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPO1lBQ3hCLFdBQVcsRUFBRSxPQUFPLENBQUMsV0FBVyxJQUFJLDZCQUFtQixDQUFDLFVBQVU7U0FDbEUsQ0FBQyxDQUFDO0lBQ0osQ0FBQztDQUNEO0FBdExELGdDQXNMQztBQUVELFNBQVMsV0FBVyxDQUFDLEtBQWE7SUFDakMsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO0lBQ3RFLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDWCxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7S0FDdkM7SUFFRCxPQUFPLEVBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBQyxDQUFDO0FBQzlELENBQUMifQ==